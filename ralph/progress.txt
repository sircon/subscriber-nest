# Ralph Progress Log
Started: Sun Jan 18 21:49:22 CET 2026
---

## Codebase Patterns
- Use `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS` in migrations for idempotency
- For foreign keys in migrations, use `DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '...') THEN ... END IF; END $$;` pattern to avoid constraint conflicts
- Migrations use raw SQL queries with IF NOT EXISTS checks rather than TypeORM's createTable/createForeignKey methods for better control
- Entity files use TypeORM decorators: `@Entity()`, `@PrimaryGeneratedColumn('uuid')`, `@Column()`, `@ManyToOne()`, `@JoinColumn()`, `@Index()`
- Always register new entities in `app.module.ts` `TypeOrmModule.forFeature([...])` array
- Run `nest build` before `migration:run` because migrations are compiled to `dist/migrations/`

## Sun Jan 18 21:50:52 CET 2026 - US-001
- Created OAuthState entity with all required fields (id, userId, espType, state, redirectUri, expiresAt, createdAt)
- Added unique index on `state` field and composite index on `userId` and `espType` for cleanup queries
- Created migration file `1768744000000-CreateOAuthState.ts` using IF NOT EXISTS patterns for idempotency
- Updated `app.module.ts` to include OAuthState entity in TypeOrmModule.forFeature
- Migration executed successfully
- Files changed:
  - `apps/backend/src/entities/oauth-state.entity.ts` (new)
  - `apps/backend/src/migrations/1768744000000-CreateOAuthState.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - This codebase uses raw SQL with IF NOT EXISTS patterns in newer migrations (like CreateBillingUsage) rather than TypeORM's createTable/createForeignKey methods
  - Foreign key constraints need explicit IF NOT EXISTS checks using `DO $$ BEGIN ... IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '...') ... END $$;` pattern
  - The `esp_type_enum` already exists from previous migrations, so we can reuse it for OAuthState entity
  - Indexes can use `CREATE INDEX IF NOT EXISTS` directly in SQL
  - Always use `CREATE TABLE IF NOT EXISTS` to handle cases where table might already exist (e.g., from synchronize mode in development)
  - When making existing columns nullable, use `ALTER COLUMN ... DROP NOT NULL` in migrations
  - When adding new enum types, use `DO $$ BEGIN CREATE TYPE ... EXCEPTION WHEN duplicate_object THEN null; END $$;` pattern
  - For ALTER TABLE operations, can use `ADD COLUMN IF NOT EXISTS` for idempotency
  - When updating entities to support new auth methods, add null checks in services that use the old fields to prevent runtime errors
---

## Sun Jan 18 22:15:00 CET 2026 - US-002
- Updated EspConnection entity to support OAuth authentication method
- Added `authMethod` enum field (api_key, oauth) with default 'api_key'
- Made `encryptedApiKey` nullable (required only for API key auth)
- Added `encryptedAccessToken`, `encryptedRefreshToken`, `tokenExpiresAt` fields for OAuth tokens
- Added `publicationIds` JSONB field to store array of publication IDs for OAuth connections
- Made `publicationId` nullable (OAuth connections use `publicationIds` array)
- Created migration `1768744100000-UpdateEspConnectionForOAuth.ts` with all schema changes
- Updated `EspConnectionService.createConnection()` to set `authMethod: 'api_key'` for API key connections
- Added null checks in `EspConnectionService.getSubscriberCount()` and `SubscriberSyncService.syncSubscribers()` to handle nullable fields
- Migration executed successfully, all columns added correctly
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` (updated)
  - `apps/backend/src/migrations/1768744100000-UpdateEspConnectionForOAuth.ts` (new)
  - `apps/backend/src/services/esp-connection.service.ts` (updated)
  - `apps/backend/src/services/subscriber-sync.service.ts` (updated)
- **Learnings for future iterations:**
  - When making existing columns nullable, existing code that uses those fields needs null checks
  - Services that use API key fields should validate `authMethod === 'api_key'` before accessing those fields
  - The migration pattern for adding enum columns uses TypeORM's `getTable()` to check existence, then raw SQL `ADD COLUMN IF NOT EXISTS`
  - TypeORM's synchronize mode in development can create tables, so migrations should be idempotent
---

## Sun Jan 18 21:54:09 CET 2026 - US-003
- Created OAuthStateService with all required methods: `createState()`, `validateState()`, and `deleteState()`
- `createState()` generates a random 32-byte state string using `crypto.randomBytes()` and stores it with 10-minute expiry
- `validateState()` validates state token, checks expiry, and returns user info (throws NotFoundException if invalid/expired)
- `deleteState()` removes state after use
- Added `cleanupExpiredStates()` method for scheduled cleanup job
- Created OAuthStateCleanupProcessor to handle cleanup jobs via BullMQ
- Created OAuthStateSchedulerService that schedules hourly cleanup job (runs at minute 0 of every hour)
- Registered oauth-state-cleanup queue in BullModule
- All services and processor registered in app.module.ts
- Files changed:
  - `apps/backend/src/services/oauth-state.service.ts` (new)
  - `apps/backend/src/processors/oauth-state-cleanup.processor.ts` (new)
  - `apps/backend/src/services/oauth-state-scheduler.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - Scheduled jobs in this codebase use BullMQ queues with `@InjectQueue` and `OnModuleInit` pattern
  - Processors extend `WorkerHost` and implement `process()` method
  - Scheduler services check for existing repeatable jobs before scheduling to avoid duplicates
  - Use `crypto.randomBytes()` for generating secure random strings (32 bytes = 64 hex characters)
  - State validation should check expiry and delete expired states to prevent reuse
  - Always register new queues in `BullModule.registerQueue()` and processors/services in `providers` array
  - Cron pattern "0 * * * *" means "every hour at minute 0"
---

## [Date/Time] - US-004
- Created OAuthConfigService to manage OAuth configuration for Kit and Mailchimp
- Service reads OAuth config from environment variables (client ID, client secret, authorization URL, token URL, scopes)
- Validates all required config values are present on initialization (throws error if missing)
- Implements `getConfig(espType: EspType): OAuthConfig` method that returns configuration for specified ESP
- Supports Kit and Mailchimp OAuth configurations
- Registered service in app.module.ts providers array
- Files changed:
  - `apps/backend/src/services/oauth-config.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - ConfigService is available globally via `ConfigModule.forRoot({ isGlobal: true })`
  - Access environment variables using `this.configService.get<string>('ENV_VAR_NAME')`
  - Validation in constructor throws error on initialization if required values are missing (fail-fast pattern)
  - Service throws descriptive errors indicating which environment variables are missing
  - OAuthConfig interface exported for use by other services
---

## Sun Jan 19 2026 - US-005
- Created OAuth initiate endpoint `GET /esp-connections/oauth/initiate/:provider` in EspConnectionController
- Endpoint accepts 'kit' or 'mailchimp' as provider parameter and validates input
- Endpoint requires authentication via `@UseGuards(AuthGuard)` (inherited from controller-level guard)
- Creates OAuth state using OAuthStateService with user ID, ESP type, and redirect URI
- Builds OAuth authorization URL with all required parameters: client_id, redirect_uri, response_type=code, scope, state
- Redirect URI constructed as `{BACKEND_URL}/api/esp-connections/oauth/callback/{provider}` using ConfigService (falls back to BACKEND_URL or API_URL env vars, defaults to localhost:4000)
- Redirects user to ESP's OAuth authorization page using Express Response.redirect()
- Handles errors appropriately: BadRequestException for invalid provider, InternalServerErrorException for missing OAuth config
- Files changed:
  - `apps/backend/src/controllers/esp-connection.controller.ts` (updated)
- **Learnings for future iterations:**
  - OAuth routes should be placed before parameterized routes (e.g., `:id`) to avoid route conflicts
  - Use `@Res()` decorator with Express Response type for redirects in NestJS controllers
  - ConfigService is globally available, can inject directly into controllers
  - For OAuth redirect URIs, prefer environment variable (BACKEND_URL) but can fallback to constructing from request if needed
  - Map provider strings ('kit', 'mailchimp') to EspType enum values when calling services
  - Use URL constructor and URLSearchParams for building OAuth authorization URLs cleanly
  - Controller-level `@UseGuards(AuthGuard)` applies to all routes in the controller
---
