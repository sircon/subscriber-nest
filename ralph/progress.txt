# Ralph Progress Log
Started: Sat Jan 17 2026
---

## Codebase Patterns
- TypeORM entities are placed in `src/entities/` directory with `.entity.ts` extension
- Migrations are placed in `src/migrations/` and use timestamp-based naming (e.g., `1737129600000-MigrationName.ts`)
- PostgreSQL enum types must be created explicitly in migrations using `CREATE TYPE` with `DO $$ BEGIN ... EXCEPTION ... END $$;` pattern to handle existing types
- Entities use TypeORM decorators: `@Entity()`, `@PrimaryGeneratedColumn('uuid')`, `@Column()`, `@CreateDateColumn()`, `@UpdateDateColumn()`
- Foreign keys use `@ManyToOne()` and `@JoinColumn()` decorators
- Unique constraints use `@Index()` decorator with `isUnique: true`
- The data-source.ts file uses `entities: ['src/**/*.entity.ts']` pattern to auto-discover entities
- Migrations reference built files in `dist/migrations/*.js` but source files are in `src/migrations/`

## 2026-01-17 - US-001
- Created `EspConnection` entity with all required fields: id (UUID), userId, espType (enum), encryptedApiKey, publicationId, status (enum), lastValidatedAt, createdAt, updatedAt
- Created `Subscriber` entity with all required fields: id (UUID), espConnectionId (FK), externalId, encryptedEmail, maskedEmail, status (enum), firstName, lastName, subscribedAt, unsubscribedAt, metadata (JSONB), createdAt, updatedAt
- Created migration file `1737129600000-CreateEspConnectionAndSubscriber.ts` with proper PostgreSQL enum type creation
- Added unique index on `espConnectionId + externalId` for subscribers table
- Added foreign key relationship from subscribers to esp_connections with CASCADE delete
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` (new)
  - `apps/backend/src/entities/subscriber.entity.ts` (new)
  - `apps/backend/src/migrations/1737129600000-CreateEspConnectionAndSubscriber.ts` (new)
- **Learnings for future iterations:**
  - PostgreSQL requires explicit enum type creation in migrations before using them in table columns
  - Use `DO $$ BEGIN ... EXCEPTION WHEN duplicate_object THEN null; END $$;` pattern to safely create enum types that may already exist
  - TypeORM's `@Index()` decorator with `isUnique: true` creates a unique constraint, which is needed for the upsert pattern in US-013
  - The `@OneToMany()` relationship on EspConnection and `@ManyToOne()` on Subscriber creates the proper bidirectional relationship
  - Migration files should include both `up()` and `down()` methods for rollback capability

## 2026-01-18 - US-002
- Created `EncryptionService` with `encrypt()` and `decrypt()` methods using AES-256-GCM encryption
- Service uses `ENCRYPTION_KEY` environment variable and derives a 256-bit key using PBKDF2
- Implemented error handling for encryption/decryption failures with descriptive error messages
- Uses AES-256-GCM algorithm for authenticated encryption (provides both confidentiality and authenticity)
- Encryption format: `iv:tag:encryptedData` (all base64 encoded) to support unique IV per encryption
- Added `EncryptionService` to `AppModule` providers
- Files changed:
  - `apps/backend/src/services/encryption.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include EncryptionService)
- **Learnings for future iterations:**
  - Services are placed in `src/services/` directory with `.service.ts` extension
  - Use Node.js built-in `crypto` module for encryption (no external dependencies needed)
  - AES-256-GCM provides authenticated encryption, which is more secure than CBC mode
  - PBKDF2 key derivation ensures consistent 256-bit key regardless of input key length
  - Each encryption uses a unique IV (initialization vector) for security
  - The service throws descriptive errors if `ENCRYPTION_KEY` is missing or if encryption/decryption fails
  - ConfigService is already available globally via `ConfigModule.forRoot({ isGlobal: true })` in AppModule

## 2026-01-18 - US-003
- Created `maskEmail()` utility function in `src/utils/email.util.ts` that masks the local part of email addresses while keeping the domain visible
- Function handles edge cases: single character emails (e.g., "a@example.com" → "a****@example.com"), very short emails, and invalid formats (throws descriptive errors)
- Uses regex validation to ensure email format is valid before processing
- Masking pattern: shows first character of local part followed by 4 asterisks (e.g., "john.doe@example.com" → "j****@example.com")
- Files changed:
  - `apps/backend/src/utils/email.util.ts` (new)
- **Learnings for future iterations:**
  - Utility functions (non-injectable, pure functions) are placed in `src/utils/` directory with `.util.ts` extension
  - Email validation uses regex pattern `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` to ensure basic email format
  - The function throws descriptive errors for invalid inputs (empty strings, non-string types, invalid format)
  - Masking always shows the first character of the local part for consistency, even for single-character emails
---
