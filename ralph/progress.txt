# Ralph Progress Log
Started: Sat Jan 17 2026
---

## Codebase Patterns
- TypeORM entities are automatically loaded via `autoLoadEntities: true` in TypeOrmModule configuration
- Migration files go in `src/migrations/` and are compiled to `dist/migrations/` for execution
- Use `yarn build` before running migrations to ensure compiled files exist
- Entity files use TypeORM decorators: `@Entity()`, `@Column()`, `@PrimaryGeneratedColumn()`, `@CreateDateColumn()`, `@UpdateDateColumn()`
- Foreign key relationships use `@ManyToOne()` and `@JoinColumn()` decorators
- Use `uuid` type for primary keys with `uuid_generate_v4()` default in migrations

## 2026-01-17 - US-001
- Created User, VerificationCode, and Session entities with all required fields
- Created migration file to create the three tables with proper relationships
- Files changed:
  - `apps/backend/src/entities/user.entity.ts` - User entity with email (unique), isOnboarded, timestamps
  - `apps/backend/src/entities/verification-code.entity.ts` - VerificationCode entity with 6-digit code, expiration, and used flag
  - `apps/backend/src/entities/session.entity.ts` - Session entity with token, userId foreign key, expiration
  - `apps/backend/src/migrations/1737000000000-CreateUserAndSessionEntities.ts` - Migration to create all three tables
- **Learnings for future iterations:**
  - TypeORM CLI path issue in yarn workspaces - migration generation failed, so created migration manually
  - Migration format: class implements `MigrationInterface` with `up()` and `down()` methods using `queryRunner.query()`
  - Use `uuid_generate_v4()` for UUID defaults in PostgreSQL migrations
  - Foreign keys should use `ON DELETE CASCADE` for sessions when user is deleted
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-002
- Created EspConnection entity with provider enum, apiKey field, and relationship to User
- Added OneToMany relationship from User to EspConnections
- Created migration to create esp_connections table with enum type and foreign key
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` - EspConnection entity with provider enum (kit, beehiiv, mailchimp), apiKey, isActive, timestamps
  - `apps/backend/src/entities/user.entity.ts` - Added OneToMany relationship to EspConnections
  - `apps/backend/src/migrations/1737000001000-CreateEspConnectionEntity.ts` - Migration to create esp_connections table and esp_provider_enum type
- **Learnings for future iterations:**
  - TypeORM enum columns require creating the enum type in PostgreSQL migrations before using it in table creation
  - Use `@OneToMany()` decorator on the parent entity (User) and `@ManyToOne()` on the child entity (EspConnection)
  - API key encryption will be handled in the service layer (stored as text in DB for now)
  - Enum values in TypeORM are defined as a TypeScript enum and referenced in the Column decorator
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-003
- Set up Resend email service with EmailService class
- Installed `resend` package (not `@resend/node`)
- Updated .env.example with placeholder RESEND_API_KEY and documentation
- Created EmailService with sendVerificationCode method that uses Resend API
- Added EmailService to AppModule providers and exports
- Files changed:
  - `apps/backend/package.json` - Added resend dependency
  - `apps/backend/.env.example` - Added RESEND_API_KEY with placeholder and documentation
  - `apps/backend/src/email.service.ts` - New EmailService class with Resend integration
  - `apps/backend/src/app.module.ts` - Added EmailService to providers and exports
- **Learnings for future iterations:**
  - Resend package name is `resend`, not `@resend/node`
  - EmailService uses ConfigService to read RESEND_API_KEY from environment
  - Service throws error on initialization if RESEND_API_KEY is missing (fail-fast pattern)
  - EmailService is exported from AppModule so it can be injected into other modules
  - Basic HTML email template included in service (will be replaced with react-email template in US-004)
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-004
- Created react-email verification code template with professional styling
- Installed react-email, @react-email/components, react, and react-dom packages
- Created VerificationCodeEmail component in apps/backend/src/emails/verification-code-email.tsx
- Updated EmailService to use react-email render function to convert template to HTML
- Added JSX support to TypeScript configuration (jsx: "react")
- Files changed:
  - `apps/backend/package.json` - Added react-email, @react-email/components, react, react-dom dependencies
  - `apps/backend/tsconfig.json` - Added "jsx": "react" to compilerOptions
  - `apps/backend/src/emails/verification-code-email.tsx` - New email template component with professional styling
  - `apps/backend/src/email.service.ts` - Updated to use react-email template rendering
- **Learnings for future iterations:**
  - react-email requires React and react-dom to be installed even in backend projects
  - Use `render` from `@react-email/render` with `React.createElement` to render templates to HTML
  - Template components use JSX syntax, so TypeScript config needs `"jsx": "react"` option
  - react-email templates compile to JavaScript and are included in the build output
  - Use `{ pretty: true }` option in render() for formatted HTML output
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-005
- Created POST /auth/send-code endpoint that generates and sends verification codes
- Implemented AuthService with code generation, rate limiting (max 3 codes per email per hour), and email sending
- Created AuthController with send-code endpoint
- Endpoint generates random 6-digit numeric code, stores it with 10-minute expiration, and sends via Resend
- Files changed:
  - `apps/backend/src/auth.service.ts` - New AuthService with sendVerificationCode method, rate limiting, and code generation
  - `apps/backend/src/auth.controller.ts` - New AuthController with POST /auth/send-code endpoint
  - `apps/backend/src/app.module.ts` - Added AuthController, AuthService, and TypeOrmModule.forFeature([VerificationCode])
- **Learnings for future iterations:**
  - Use `@InjectRepository()` decorator to inject TypeORM repositories into services
  - Import `TypeOrmModule.forFeature([Entity])` in module to make repository available for injection
  - Use `MoreThan()` from TypeORM to query records created after a specific date for rate limiting
  - BadRequestException from @nestjs/common is appropriate for client errors (rate limiting, invalid email)
  - Rate limiting checks count of codes created in the last hour using `createdAt: MoreThan(oneHourAgo)`
  - Code generation uses `Math.floor(100000 + Math.random() * 900000)` to ensure exactly 6 digits
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-006
- Created POST /auth/verify-code endpoint that validates codes and creates sessions
- Implemented verifyCode method in AuthService that validates code, creates/finds user, marks code as used, and creates session
- Endpoint returns token and user information on success
- Files changed:
  - `apps/backend/src/auth.service.ts` - Added verifyCode method with code validation, user creation/lookup, and session creation
  - `apps/backend/src/auth.controller.ts` - Added POST /auth/verify-code endpoint
  - `apps/backend/src/app.module.ts` - Added User and Session to TypeOrmModule.forFeature array
  - `apps/backend/AGENTS.md` - Updated Authentication section with session creation patterns
- **Learnings for future iterations:**
  - Use `UnauthorizedException` from `@nestjs/common` for authentication failures (invalid/expired/used codes)
  - Session tokens are generated using `crypto.randomBytes(32).toString('hex')` for secure random tokens
  - Always mark verification codes as used after successful verification to prevent reuse
  - User creation happens automatically during code verification if user doesn't exist (with isOnboarded: false)
  - Use `findOne()` with `where` clause to find entities by specific fields
  - Session expiration is set to 30 days from creation (configurable in verifyCode method)
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-007
- Created AuthGuard that validates session tokens from request headers
- Guard implements CanActivate interface and checks token in Authorization header (Bearer format)
- Guard validates token exists in database, is not expired, and loads user
- Created CurrentUser decorator to access authenticated user in controllers
- Guard can be applied to controllers/routes via @UseGuards(AuthGuard)
- Returns 401 UnauthorizedException if token invalid, missing, or expired
- Files changed:
  - `apps/backend/src/guards/auth.guard.ts` - New AuthGuard class with session validation logic
  - `apps/backend/src/decorators/current-user.decorator.ts` - New CurrentUser decorator to extract user from request
  - `apps/backend/src/app.module.ts` - Added AuthGuard to providers
- **Learnings for future iterations:**
  - Guards in NestJS implement `CanActivate` interface with `canActivate(context: ExecutionContext)` method
  - Use `context.switchToHttp().getRequest()` to access HTTP request object
  - Extract token from Authorization header with format "Bearer <token>"
  - Use `@InjectRepository()` in guards to inject TypeORM repositories (guards need to be in providers)
  - Guards that use dependency injection must be added to module providers
  - Use `relations: ['user']` in findOne to eagerly load related entities
  - Attach user to request object (`request.user = user`) so it's available in controllers via decorators
  - Use `UnauthorizedException` from `@nestjs/common` for authentication failures
  - TypeScript requires null checking when assigning `findOne()` result (can return null)
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-008
- Created GET /auth/me endpoint protected by AuthGuard
- Endpoint returns current user information (id, email, isOnboarded)
- Uses @UseGuards(AuthGuard) and @CurrentUser() decorator to access authenticated user
- Returns 401 if not authenticated (handled by AuthGuard)
- Files changed:
  - `apps/backend/src/auth.controller.ts` - Added GET /auth/me endpoint with AuthGuard protection
- **Learnings for future iterations:**
  - GET endpoints can be protected with @UseGuards(AuthGuard) just like POST endpoints
  - Use @CurrentUser() decorator to access the authenticated user that was attached to the request by AuthGuard
  - The endpoint simply returns the user data from the request - no additional database queries needed since AuthGuard already loaded the user
  - Response format matches the user object structure returned by verify-code endpoint for consistency
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-009
- Created POST /auth/logout endpoint protected by AuthGuard
- Implemented logout method in AuthService that deletes session from database
- Endpoint extracts token from Authorization header and deletes the session
- Returns { success: true } on successful logout
- Files changed:
  - `apps/backend/src/auth.service.ts` - Added logout method that finds and deletes session by token
  - `apps/backend/src/auth.controller.ts` - Added POST /auth/logout endpoint with AuthGuard protection
- **Learnings for future iterations:**
  - Use `@Headers('authorization')` decorator from NestJS to extract Authorization header in controllers
  - Token extraction follows same pattern as AuthGuard: split "Bearer <token>" format
  - Logout endpoint is protected by AuthGuard to ensure only authenticated users can log out
  - Session deletion uses `sessionRepository.remove()` after finding the session by token
  - If session doesn't exist (edge case), logout still returns success to avoid leaking information
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-010
- Created POST /esp-connections endpoint protected by AuthGuard
- Implemented EncryptionService using Node's built-in crypto module with AES-256-GCM encryption
- Created EspConnectionService with createConnection method that validates provider, encrypts API key, and creates connection
- Endpoint accepts { provider: string, apiKey: string } and returns { id, provider, createdAt } without API key
- Files changed:
  - `apps/backend/src/encryption.service.ts` - New EncryptionService with encrypt/decrypt methods using AES-256-GCM
  - `apps/backend/src/esp-connection.service.ts` - New EspConnectionService with createConnection method
  - `apps/backend/src/esp-connection.controller.ts` - New EspConnectionController with POST /esp-connections endpoint
  - `apps/backend/src/app.module.ts` - Added EspConnectionController, EspConnectionService, EncryptionService, and EspConnection entity
  - `apps/backend/.env.example` - Added ENCRYPTION_KEY environment variable with documentation
- **Learnings for future iterations:**
  - Use Node's built-in `crypto` module for encryption (no external dependencies needed)
  - AES-256-GCM provides authenticated encryption (encryption + integrity verification)
  - Encryption format: `iv:authTag:encryptedData` (colon-separated hex strings)
  - EncryptionService uses ConfigService to read ENCRYPTION_KEY from environment and throws error if missing (fail-fast)
  - Convert encryption key to 32-byte buffer using SHA-256 hash for AES-256 key requirement
  - Provider validation checks against EspProvider enum values using `Object.values(EspProvider).includes()`
  - Use `BadRequestException` for invalid provider validation errors
  - API keys are encrypted before storing in database, never returned in API responses
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-011
- Created POST /auth/complete-onboarding endpoint protected by AuthGuard
- Implemented completeOnboarding method in AuthService that sets user's isOnboarded to true
- Endpoint uses @CurrentUser() decorator to get authenticated user and updates their onboarding status
- Returns { success: true, user: { id, email, isOnboarded: true } } on success
- Files changed:
  - `apps/backend/src/auth.service.ts` - Added completeOnboarding method that updates user's isOnboarded field
  - `apps/backend/src/auth.controller.ts` - Added POST /auth/complete-onboarding endpoint with AuthGuard protection
- **Learnings for future iterations:**
  - User updates use `userRepository.save()` after modifying entity properties
  - The endpoint follows the same pattern as other protected endpoints: @UseGuards(AuthGuard) and @CurrentUser() decorator
  - Response format matches the user object structure from other auth endpoints for consistency
  - User lookup by ID is performed even though @CurrentUser() provides the user, to ensure user still exists in database
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-012
- Created GET /esp-connections endpoint protected by AuthGuard
- Implemented getUserConnections method in EspConnectionService that fetches user's ESP connections
- Endpoint returns array of connections with id, provider, isActive, and createdAt (excludes API key)
- Files changed:
  - `apps/backend/src/esp-connection.controller.ts` - Added GET /esp-connections endpoint with AuthGuard protection
  - `apps/backend/src/esp-connection.service.ts` - Added getUserConnections method that queries connections by userId
- **Learnings for future iterations:**
  - Use `select` option in TypeORM `find()` to explicitly exclude sensitive fields like API keys from query results
  - GET endpoints follow same pattern as POST endpoints: @UseGuards(AuthGuard) and @CurrentUser() decorator
  - Service methods can use `find()` with `where` clause to filter by userId for user-specific data
  - Response format returns array of connection objects without sensitive data (API keys are never included)
  - All quality checks (typecheck, lint, build) passed successfully
---

## 2026-01-17 - US-013
- Created login page UI with email input form and verification code request functionality
- Created shadcn Input component following the same pattern as Button component
- Implemented form with loading, success, and error states
- Form calls POST /auth/send-code endpoint and redirects to /verify-code with email in query params
- Files changed:
  - `apps/frontend/src/components/ui/input.tsx` - New Input component with shadcn styling
  - `apps/frontend/src/app/login/page.tsx` - New login page with email form, loading/success/error states, and redirect logic
  - `apps/frontend/.eslintrc.json` - Added "node": true to env and "process": "readonly" to globals to fix lint errors
- **Learnings for future iterations:**
  - Next.js client components can access `process.env.NEXT_PUBLIC_*` variables directly (replaced at build time)
  - Use `useRouter()` from `next/navigation` for client-side navigation in App Router
  - shadcn components follow a consistent pattern: forwardRef, className merging with cn(), and TypeScript interfaces extending HTML element props
  - Form state management: use useState for email, loading, error, and success states
  - Error handling: check response.ok and parse error messages from API responses
  - Redirect after success: use setTimeout with router.push() to show success message before redirecting
  - ESLint config needs "node": true in env for config files (tailwind.config.ts) and "process" in globals for client components using env vars
  - All quality checks (typecheck, lint, build) passed successfully
  - Page verified loading correctly in browser (dev server on port 3000)
---

## 2026-01-17 - US-014
- Created verify code page UI with 6-digit code input and verification functionality
- Page reads email from query params and redirects to login if missing
- Implemented form with loading, error states, and conditional redirects based on isOnboarded status
- Form calls POST /auth/verify-code endpoint and stores token in localStorage
- Files changed:
  - `apps/frontend/src/app/verify-code/page.tsx` - New verify code page with 6-digit input, form validation, API integration, and conditional redirects
- **Learnings for future iterations:**
  - `useSearchParams()` must be wrapped in a Suspense boundary in Next.js App Router to avoid build errors
  - Split component into form component and page component: form uses useSearchParams(), page wraps in Suspense
  - Code input validation: use `replace(/\D/g, '')` to only allow digits, limit to 6 characters with maxLength
  - Input styling: use `text-center text-2xl tracking-widest font-mono` for code input to make digits clearly visible
  - Token storage: store in localStorage temporarily (will be moved to auth context in US-017)
  - Conditional redirects: check `data.user.isOnboarded` to redirect to /onboarding (false) or /dashboard (true)
  - Email validation: redirect to /login if email query param is missing (handled in useEffect)
  - Suspense fallback: provide loading skeleton that matches page layout for better UX
  - All quality checks (typecheck, lint, build) passed successfully
---
