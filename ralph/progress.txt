# Ralph Progress Log
Started: Sun Jan 18 12:24:26 CET 2026
---

## 2026-01-18 12:25:26 - US-001
- Created `BillingSubscription` entity with all required fields (id, userId, stripeCustomerId, stripeSubscriptionId, stripePriceId, status enum, currentPeriodStart, currentPeriodEnd, cancelAtPeriodEnd, canceledAt, createdAt, updatedAt)
- Added `@OneToOne` relationship from `BillingSubscription` to `User` entity
- Added inverse `@OneToOne` relationship from `User` to `BillingSubscription` entity
- Registered `BillingSubscription` entity in `AppModule` TypeOrmModule.forFeature array
- Generated migration `1768735510135-CreateBillingSubscription.ts` which creates the table with proper enum type, unique constraints, and foreign key
- Files changed:
  - `apps/backend/src/entities/billing-subscription.entity.ts` (new)
  - `apps/backend/src/entities/user.entity.ts` (added relationship)
  - `apps/backend/src/app.module.ts` (registered entity)
  - `apps/backend/src/migrations/1768735510135-CreateBillingSubscription.ts` (new)
- **Learnings for future iterations:**
  - TypeORM OneToOne relationships require `@JoinColumn` on the side that owns the foreign key (BillingSubscription side)
  - When adding new entities, must register them in `TypeOrmModule.forFeature([...])` in the module
  - Migration generation requires building the project first (`nest build`) to compile TypeScript
  - Enum types are automatically created in migrations when using TypeORM enum columns
  - Unique constraints are automatically added for `@Column({ unique: true })` decorators
---

## 2026-01-18 12:26:50 - US-002
- Created `BillingUsage` entity with all required fields (id, userId, billingPeriodStart, billingPeriodEnd, maxSubscriberCount, calculatedAmount with decimal precision 10 scale 2, stripeInvoiceId, status enum, createdAt, updatedAt)
- Added `@ManyToOne` relationship from `BillingUsage` to `User` entity
- Added inverse `@OneToMany` relationship from `User` to `BillingUsage` entity
- Added unique index on `userId` + `billingPeriodStart` using `@Index` decorator to prevent duplicate billing periods per user
- Registered `BillingUsage` entity in `AppModule` TypeOrmModule.forFeature array
- Generated migration `1768735595273-CreateBillingUsage.ts` which creates the table with proper enum type, decimal column (numeric(10,2)), unique composite index, and foreign key
- Files changed:
  - `apps/backend/src/entities/billing-usage.entity.ts` (new)
  - `apps/backend/src/entities/user.entity.ts` (added relationship)
  - `apps/backend/src/app.module.ts` (registered entity)
  - `apps/backend/src/migrations/1768735595273-CreateBillingUsage.ts` (new)
- **Learnings for future iterations:**
  - TypeORM decimal columns use `type: 'decimal'` with `precision` and `scale` options, which generates `numeric(precision, scale)` in PostgreSQL
  - Composite unique indexes are created using `@Index(['field1', 'field2'], { unique: true })` decorator at the entity class level
  - TypeORM ManyToOne relationships require `@JoinColumn` on the side that owns the foreign key (BillingUsage side)
  - Migration generation automatically creates enum types, foreign key constraints, and indexes based on entity decorators
---

## 2026-01-19 - US-003
- Installed `stripe` npm package (v20.2.0) in backend
- Added `STRIPE_SECRET_KEY` and `STRIPE_WEBHOOK_SECRET` environment variables to `.env.example`
- Created `StripeService` with initialization of Stripe client using ConfigService
- Service validates both Stripe keys are configured on initialization (fail-fast pattern)
- Service provides `getClient()` method to access Stripe instance and `getWebhookSecret()` method for webhook verification
- Registered `StripeService` in `AppModule` providers array
- Files changed:
  - `apps/backend/package.json` (added stripe dependency)
  - `apps/backend/.env.example` (added Stripe environment variables)
  - `apps/backend/src/services/stripe.service.ts` (new)
  - `apps/backend/src/app.module.ts` (registered service)
- **Learnings for future iterations:**
  - Stripe API version must match the version supported by the installed stripe package (currently '2025-12-15.clover')
  - Services that require environment variables should validate them in constructor using fail-fast pattern (throw error if missing)
  - Use `ConfigService` from `@nestjs/config` to read environment variables (already configured globally in AppModule)
  - Stripe client initialization requires secret key, webhook secret is stored separately for webhook signature verification
---

## 2026-01-18 12:29:01 - US-004
- Added `createCustomer(email: string, userId: string): Promise<Stripe.Customer>` method to `StripeService`
- Method creates Stripe customer with email and metadata containing userId
- Method returns Stripe customer object
- Implemented error handling: catches Stripe API errors and wraps them in `InternalServerErrorException` with descriptive messages
- Added import for `InternalServerErrorException` from `@nestjs/common`
- Files changed:
  - `apps/backend/src/services/stripe.service.ts` (added createCustomer method)
- **Learnings for future iterations:**
  - Stripe errors are instances of `Stripe.errors.StripeError` and can be caught and handled appropriately
  - Use `InternalServerErrorException` from `@nestjs/common` for external API errors (following pattern from other services)
  - Stripe customer metadata is useful for linking Stripe customers to internal user IDs
  - Always wrap external API calls in try-catch blocks to handle errors gracefully
---

## 2026-01-19 - US-005
- Added `STRIPE_PRICE_ID` environment variable to `.env.example` for metered billing price configuration
- Implemented `createSubscription(customerId: string): Promise<Stripe.Subscription>` method in `StripeService`
- Method creates Stripe subscription with monthly billing cycle using price ID from environment
- Subscription uses metered billing (usage-based pricing) via the configured price ID
- Implemented `cancelSubscription(subscriptionId: string, cancelAtPeriodEnd: boolean): Promise<Stripe.Subscription>` method
- Method supports both immediate cancellation and cancellation at period end based on `cancelAtPeriodEnd` parameter
- Implemented `getSubscription(subscriptionId: string): Promise<Stripe.Subscription>` method to retrieve subscription details
- All methods include proper error handling with `InternalServerErrorException` for Stripe API errors
- Files changed:
  - `apps/backend/.env.example` (added STRIPE_PRICE_ID)
  - `apps/backend/src/services/stripe.service.ts` (added createSubscription, cancelSubscription, getSubscription methods)
- **Learnings for future iterations:**
  - Stripe subscriptions for metered billing require a price ID configured in environment variables
  - For monthly billing, Stripe automatically handles billing cycles - no need to set `billing_cycle_anchor` explicitly
  - Stripe subscription cancellation can be immediate (`subscriptions.cancel()`) or at period end (`subscriptions.update()` with `cancel_at_period_end: true`)
  - When creating subscriptions, the price ID must be configured in Stripe Dashboard with `usage_type: 'metered'` for usage-based pricing
  - Stripe subscription creation only requires `customer` and `items` with `price` - billing cycle is determined by the price configuration
---

## 2026-01-19 - US-006
- Created `BillingCalculationService` with `calculateAmount(subscriberCount: number): number` method
- Implemented tiered pricing logic: $5 for first 10,000 subscribers, then $1 per each additional 10,000 subscribers
- Method handles edge cases: returns $0 for 0 or negative subscribers, handles very large numbers correctly
- Method rounds to 2 decimal places to handle floating point precision issues
- Registered `BillingCalculationService` in `AppModule` providers array
- Files changed:
  - `apps/backend/src/services/billing-calculation.service.ts` (new)
  - `apps/backend/src/app.module.ts` (registered service)
- **Learnings for future iterations:**
  - Services that don't require dependencies (like calculation services) can be simple `@Injectable()` classes without constructor injection
  - When implementing tiered pricing, use `Math.ceil()` to round up to the next tier (e.g., 15,001 subscribers should be charged for 2 additional tiers)
  - Always handle edge cases (0, negative numbers) explicitly in calculation methods
  - Round monetary calculations to 2 decimal places to avoid floating point precision issues
---

## 2026-01-18 12:33:03 - US-007
- Created `BillingUsageService` with `updateUsage(userId: string, currentSubscriberCount: number): Promise<void>` method
- Method finds or creates `BillingUsage` record for current billing period (calendar month)
- Method updates `maxSubscriberCount` if current count is higher than stored max
- Billing period calculation: uses `getCurrentBillingPeriod()` helper to get first day of month (00:00:00) and last day of month (23:59:59.999)
- Method calculates billing amount using `BillingCalculationService.calculateAmount()` with max subscriber count
- Method updates `calculatedAmount` field with calculated amount
- Registered `BillingUsageService` in `AppModule` providers array
- Files changed:
  - `apps/backend/src/services/billing-usage.service.ts` (new)
  - `apps/backend/src/app.module.ts` (registered service)
- **Learnings for future iterations:**
  - Calendar month billing periods: use `new Date(year, month, 1, 0, 0, 0, 0)` for start and `new Date(year, month + 1, 0, 23, 59, 59, 999)` for end (last day of month)
  - When finding billing usage records, query by `userId` and `billingPeriodStart` to leverage the unique index
  - When updating max subscriber count, only update if current count is higher (track maximum, not current)
  - Always recalculate `calculatedAmount` after updating `maxSubscriberCount` to keep billing amounts in sync
  - New billing usage records should be created with `status: BillingUsageStatus.PENDING` (will be updated to 'invoiced' when billed)
---

## 2026-01-19 - US-008
- Created `BillingProcessor` that extends BullMQ `WorkerHost` to process monthly billing jobs
- Added `billing` queue to `AppModule` with retry configuration (3 attempts, exponential backoff)
- Added `createInvoiceItem()` and `createAndFinalizeInvoice()` methods to `StripeService` for invoice management
- Created `BillingSchedulerService` that implements `OnModuleInit` to schedule monthly billing job on app startup
- Scheduled job runs on 1st day of each month at 00:00 UTC using BullMQ repeatable jobs with cron pattern `0 0 1 * *`
- Processor finds all users with active subscriptions and processes billing for each user
- For each user: retrieves `BillingUsage` for previous month, creates Stripe invoice item, finalizes invoice, updates usage record with `stripeInvoiceId` and `status: 'invoiced'`, creates new `BillingUsage` record for current month
- Processor calculates billing period dynamically (previous month) when job runs
- Error handling: logs errors per user but continues processing other users, updates usage status to 'failed' on invoice errors, re-throws errors for BullMQ retry handling
- Files changed:
  - `apps/backend/src/app.module.ts` (added billing queue, registered processor and scheduler service)
  - `apps/backend/src/services/stripe.service.ts` (added createInvoiceItem, createAndFinalizeInvoice methods)
  - `apps/backend/src/processors/billing.processor.ts` (new)
  - `apps/backend/src/services/billing-scheduler.service.ts` (new)
- **Learnings for future iterations:**
  - BullMQ repeatable jobs use `repeat: { pattern: 'cron-pattern', tz: 'UTC' }` option when adding jobs
  - Use `getRepeatableJobs()` to check if a repeatable job already exists before scheduling to avoid duplicates
  - For monthly billing jobs, calculate billing period dates dynamically in the processor based on when the job runs (not when scheduled)
  - When processing multiple users in a job, wrap each user's processing in try-catch to continue with other users if one fails
  - Stripe invoice items require amounts in cents (multiply dollars by 100), invoices are created with `auto_advance: true` to automatically finalize
  - Use `BillingUsageService.updateUsage()` to create new billing usage records for current month after processing previous month
  - Check `job.attemptsMade >= maxAttempts` to detect final retry attempt for logging permanent failures
---
