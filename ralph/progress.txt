# Ralph Progress Log
Started: Sun Jan 18 21:49:22 CET 2026
---

## Codebase Patterns
- Use `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS` in migrations for idempotency
- For foreign keys in migrations, use `DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '...') THEN ... END IF; END $$;` pattern to avoid constraint conflicts
- Migrations use raw SQL queries with IF NOT EXISTS checks rather than TypeORM's createTable/createForeignKey methods for better control
- Entity files use TypeORM decorators: `@Entity()`, `@PrimaryGeneratedColumn('uuid')`, `@Column()`, `@ManyToOne()`, `@JoinColumn()`, `@Index()`
- Always register new entities in `app.module.ts` `TypeOrmModule.forFeature([...])` array
- Run `nest build` before `migration:run` because migrations are compiled to `dist/migrations/`

## Sun Jan 18 21:50:52 CET 2026 - US-001
- Created OAuthState entity with all required fields (id, userId, espType, state, redirectUri, expiresAt, createdAt)
- Added unique index on `state` field and composite index on `userId` and `espType` for cleanup queries
- Created migration file `1768744000000-CreateOAuthState.ts` using IF NOT EXISTS patterns for idempotency
- Updated `app.module.ts` to include OAuthState entity in TypeOrmModule.forFeature
- Migration executed successfully
- Files changed:
  - `apps/backend/src/entities/oauth-state.entity.ts` (new)
  - `apps/backend/src/migrations/1768744000000-CreateOAuthState.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - This codebase uses raw SQL with IF NOT EXISTS patterns in newer migrations (like CreateBillingUsage) rather than TypeORM's createTable/createForeignKey methods
  - Foreign key constraints need explicit IF NOT EXISTS checks using `DO $$ BEGIN ... IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '...') ... END $$;` pattern
  - The `esp_type_enum` already exists from previous migrations, so we can reuse it for OAuthState entity
  - Indexes can use `CREATE INDEX IF NOT EXISTS` directly in SQL
  - Always use `CREATE TABLE IF NOT EXISTS` to handle cases where table might already exist (e.g., from synchronize mode in development)
  - When making existing columns nullable, use `ALTER COLUMN ... DROP NOT NULL` in migrations
  - When adding new enum types, use `DO $$ BEGIN CREATE TYPE ... EXCEPTION WHEN duplicate_object THEN null; END $$;` pattern
  - For ALTER TABLE operations, can use `ADD COLUMN IF NOT EXISTS` for idempotency
  - When updating entities to support new auth methods, add null checks in services that use the old fields to prevent runtime errors
---

## Sun Jan 18 22:15:00 CET 2026 - US-002
- Updated EspConnection entity to support OAuth authentication method
- Added `authMethod` enum field (api_key, oauth) with default 'api_key'
- Made `encryptedApiKey` nullable (required only for API key auth)
- Added `encryptedAccessToken`, `encryptedRefreshToken`, `tokenExpiresAt` fields for OAuth tokens
- Added `publicationIds` JSONB field to store array of publication IDs for OAuth connections
- Made `publicationId` nullable (OAuth connections use `publicationIds` array)
- Created migration `1768744100000-UpdateEspConnectionForOAuth.ts` with all schema changes
- Updated `EspConnectionService.createConnection()` to set `authMethod: 'api_key'` for API key connections
- Added null checks in `EspConnectionService.getSubscriberCount()` and `SubscriberSyncService.syncSubscribers()` to handle nullable fields
- Migration executed successfully, all columns added correctly
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` (updated)
  - `apps/backend/src/migrations/1768744100000-UpdateEspConnectionForOAuth.ts` (new)
  - `apps/backend/src/services/esp-connection.service.ts` (updated)
  - `apps/backend/src/services/subscriber-sync.service.ts` (updated)
- **Learnings for future iterations:**
  - When making existing columns nullable, existing code that uses those fields needs null checks
  - Services that use API key fields should validate `authMethod === 'api_key'` before accessing those fields
  - The migration pattern for adding enum columns uses TypeORM's `getTable()` to check existence, then raw SQL `ADD COLUMN IF NOT EXISTS`
  - TypeORM's synchronize mode in development can create tables, so migrations should be idempotent
---
