# Ralph Progress Log
Started: Sun Jan 18 21:49:22 CET 2026
---

## Codebase Patterns
- Use `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS` in migrations for idempotency
- For foreign keys in migrations, use `DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '...') THEN ... END IF; END $$;` pattern to avoid constraint conflicts
- Migrations use raw SQL queries with IF NOT EXISTS checks rather than TypeORM's createTable/createForeignKey methods for better control
- Entity files use TypeORM decorators: `@Entity()`, `@PrimaryGeneratedColumn('uuid')`, `@Column()`, `@ManyToOne()`, `@JoinColumn()`, `@Index()`
- Always register new entities in `app.module.ts` `TypeOrmModule.forFeature([...])` array
- Run `nest build` before `migration:run` because migrations are compiled to `dist/migrations/`

## Sun Jan 18 21:50:52 CET 2026 - US-001
- Created OAuthState entity with all required fields (id, userId, espType, state, redirectUri, expiresAt, createdAt)
- Added unique index on `state` field and composite index on `userId` and `espType` for cleanup queries
- Created migration file `1768744000000-CreateOAuthState.ts` using IF NOT EXISTS patterns for idempotency
- Updated `app.module.ts` to include OAuthState entity in TypeOrmModule.forFeature
- Migration executed successfully
- Files changed:
  - `apps/backend/src/entities/oauth-state.entity.ts` (new)
  - `apps/backend/src/migrations/1768744000000-CreateOAuthState.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - This codebase uses raw SQL with IF NOT EXISTS patterns in newer migrations (like CreateBillingUsage) rather than TypeORM's createTable/createForeignKey methods
  - Foreign key constraints need explicit IF NOT EXISTS checks using `DO $$ BEGIN ... IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = '...') ... END $$;` pattern
  - The `esp_type_enum` already exists from previous migrations, so we can reuse it for OAuthState entity
  - Indexes can use `CREATE INDEX IF NOT EXISTS` directly in SQL
  - Always use `CREATE TABLE IF NOT EXISTS` to handle cases where table might already exist (e.g., from synchronize mode in development)
  - When making existing columns nullable, use `ALTER COLUMN ... DROP NOT NULL` in migrations
  - When adding new enum types, use `DO $$ BEGIN CREATE TYPE ... EXCEPTION WHEN duplicate_object THEN null; END $$;` pattern
  - For ALTER TABLE operations, can use `ADD COLUMN IF NOT EXISTS` for idempotency
  - When updating entities to support new auth methods, add null checks in services that use the old fields to prevent runtime errors
---

## Sun Jan 18 22:15:00 CET 2026 - US-002
- Updated EspConnection entity to support OAuth authentication method
- Added `authMethod` enum field (api_key, oauth) with default 'api_key'
- Made `encryptedApiKey` nullable (required only for API key auth)
- Added `encryptedAccessToken`, `encryptedRefreshToken`, `tokenExpiresAt` fields for OAuth tokens
- Added `publicationIds` JSONB field to store array of publication IDs for OAuth connections
- Made `publicationId` nullable (OAuth connections use `publicationIds` array)
- Created migration `1768744100000-UpdateEspConnectionForOAuth.ts` with all schema changes
- Updated `EspConnectionService.createConnection()` to set `authMethod: 'api_key'` for API key connections
- Added null checks in `EspConnectionService.getSubscriberCount()` and `SubscriberSyncService.syncSubscribers()` to handle nullable fields
- Migration executed successfully, all columns added correctly
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` (updated)
  - `apps/backend/src/migrations/1768744100000-UpdateEspConnectionForOAuth.ts` (new)
  - `apps/backend/src/services/esp-connection.service.ts` (updated)
  - `apps/backend/src/services/subscriber-sync.service.ts` (updated)
- **Learnings for future iterations:**
  - When making existing columns nullable, existing code that uses those fields needs null checks
  - Services that use API key fields should validate `authMethod === 'api_key'` before accessing those fields
  - The migration pattern for adding enum columns uses TypeORM's `getTable()` to check existence, then raw SQL `ADD COLUMN IF NOT EXISTS`
  - TypeORM's synchronize mode in development can create tables, so migrations should be idempotent
---

## Sun Jan 18 21:54:09 CET 2026 - US-003
- Created OAuthStateService with all required methods: `createState()`, `validateState()`, and `deleteState()`
- `createState()` generates a random 32-byte state string using `crypto.randomBytes()` and stores it with 10-minute expiry
- `validateState()` validates state token, checks expiry, and returns user info (throws NotFoundException if invalid/expired)
- `deleteState()` removes state after use
- Added `cleanupExpiredStates()` method for scheduled cleanup job
- Created OAuthStateCleanupProcessor to handle cleanup jobs via BullMQ
- Created OAuthStateSchedulerService that schedules hourly cleanup job (runs at minute 0 of every hour)
- Registered oauth-state-cleanup queue in BullModule
- All services and processor registered in app.module.ts
- Files changed:
  - `apps/backend/src/services/oauth-state.service.ts` (new)
  - `apps/backend/src/processors/oauth-state-cleanup.processor.ts` (new)
  - `apps/backend/src/services/oauth-state-scheduler.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - Scheduled jobs in this codebase use BullMQ queues with `@InjectQueue` and `OnModuleInit` pattern
  - Processors extend `WorkerHost` and implement `process()` method
  - Scheduler services check for existing repeatable jobs before scheduling to avoid duplicates
  - Use `crypto.randomBytes()` for generating secure random strings (32 bytes = 64 hex characters)
  - State validation should check expiry and delete expired states to prevent reuse
  - Always register new queues in `BullModule.registerQueue()` and processors/services in `providers` array
  - Cron pattern "0 * * * *" means "every hour at minute 0"
---

## [Date/Time] - US-004
- Created OAuthConfigService to manage OAuth configuration for Kit and Mailchimp
- Service reads OAuth config from environment variables (client ID, client secret, authorization URL, token URL, scopes)
- Validates all required config values are present on initialization (throws error if missing)
- Implements `getConfig(espType: EspType): OAuthConfig` method that returns configuration for specified ESP
- Supports Kit and Mailchimp OAuth configurations
- Registered service in app.module.ts providers array
- Files changed:
  - `apps/backend/src/services/oauth-config.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
- **Learnings for future iterations:**
  - ConfigService is available globally via `ConfigModule.forRoot({ isGlobal: true })`
  - Access environment variables using `this.configService.get<string>('ENV_VAR_NAME')`
  - Validation in constructor throws error on initialization if required values are missing (fail-fast pattern)
  - Service throws descriptive errors indicating which environment variables are missing
  - OAuthConfig interface exported for use by other services
---

## Sun Jan 19 2026 - US-005
- Created OAuth initiate endpoint `GET /esp-connections/oauth/initiate/:provider` in EspConnectionController
- Endpoint accepts 'kit' or 'mailchimp' as provider parameter and validates input
- Endpoint requires authentication via `@UseGuards(AuthGuard)` (inherited from controller-level guard)
- Creates OAuth state using OAuthStateService with user ID, ESP type, and redirect URI
- Builds OAuth authorization URL with all required parameters: client_id, redirect_uri, response_type=code, scope, state
- Redirect URI constructed as `{BACKEND_URL}/api/esp-connections/oauth/callback/{provider}` using ConfigService (falls back to BACKEND_URL or API_URL env vars, defaults to localhost:4000)
- Redirects user to ESP's OAuth authorization page using Express Response.redirect()
- Handles errors appropriately: BadRequestException for invalid provider, InternalServerErrorException for missing OAuth config
- Files changed:
  - `apps/backend/src/controllers/esp-connection.controller.ts` (updated)
- **Learnings for future iterations:**
  - OAuth routes should be placed before parameterized routes (e.g., `:id`) to avoid route conflicts
  - Use `@Res()` decorator with Express Response type for redirects in NestJS controllers
  - ConfigService is globally available, can inject directly into controllers
  - For OAuth redirect URIs, prefer environment variable (BACKEND_URL) but can fallback to constructing from request if needed
  - Map provider strings ('kit', 'mailchimp') to EspType enum values when calling services
  - Use URL constructor and URLSearchParams for building OAuth authorization URLs cleanly
  - Controller-level `@UseGuards(AuthGuard)` applies to all routes in the controller
---

## Sun Jan 19 2026 - US-006
- Created OAuth callback endpoint `GET /esp-connections/oauth/callback/:provider` in EspConnectionController
- Endpoint accepts query parameters: `code` (authorization code) and `state` (OAuth state)
- Validates OAuth state using `OAuthStateService.validateState()` - throws BadRequestException for invalid/expired state
- Exchanges authorization code for access token by calling ESP's token endpoint using HttpService
- Token exchange includes: grant_type=authorization_code, code, redirect_uri, client_id, client_secret
- Encrypts access token and refresh token using EncryptionService before storing
- Stores encrypted tokens, expiry time, and creates EspConnection with OAuth auth method
- Deletes OAuth state after successful validation using `OAuthStateService.deleteState()`
- Redirects to frontend success page: `{FRONTEND_URL}/esp-connections/{connectionId}?oauth=success`
- Handles errors appropriately: BadRequestException for invalid state/missing params, InternalServerErrorException for token exchange failures
- Files changed:
  - `apps/backend/src/controllers/esp-connection.controller.ts` (updated)
- **Learnings for future iterations:**
  - OAuth callback endpoints should NOT require authentication (they're called by external OAuth providers)
  - Use `@Query()` decorator to get query parameters from OAuth callback URLs
  - HttpService from @nestjs/axios requires `firstValueFrom()` from rxjs to convert Observable to Promise
  - Token exchange requests use `application/x-www-form-urlencoded` content type with URLSearchParams
  - OAuth token responses may not always include refresh_token or expires_in - handle with defaults
  - Calculate token expiry by adding expires_in seconds to current time
  - Always delete OAuth state after successful use to prevent replay attacks
  - Redirect to frontend with connection ID and success parameter for user feedback
  - Note: Connection creation is basic implementation - will be refined in US-012 with proper `createOAuthConnection()` method
---

## Sun Jan 19 2026 - US-007
- Updated IEspConnector interface to support OAuth authentication in addition to API keys
- Added `validateAccessToken(accessToken: string): Promise<boolean>` method for OAuth token validation
- Added optional OAuth methods: `fetchPublicationsWithOAuth`, `fetchSubscribersWithOAuth`, `getSubscriberCountWithOAuth`
- OAuth methods are optional (using `?`) to maintain backward compatibility with existing API key-based connectors
- Kept all existing API key methods (`validateApiKey`, `fetchPublications`, `fetchSubscribers`, `getSubscriberCount`) unchanged
- Files changed:
  - `apps/backend/src/interfaces/esp-connector.interface.ts` (updated)
- **Learnings for future iterations:**
  - TypeScript interfaces don't support true method overloading when parameter types are identical (both `apiKey: string` and `accessToken: string` are `string`)
  - Use optional methods (with `?`) for OAuth support to maintain backward compatibility - existing connectors don't need to implement them
  - OAuth methods use descriptive names (`fetchPublicationsWithOAuth`) rather than true overloads to avoid TypeScript type ambiguity
  - Existing connectors (like BeehiivConnector) continue to work without changes since OAuth methods are optional
  - When implementing OAuth connectors (Kit, Mailchimp), they will implement the optional OAuth methods
  - The interface design allows connectors to support either API key auth, OAuth auth, or both
---

## Sun Jan 19 2026 - US-008
- Created KitConnector class implementing IEspConnector interface with OAuth methods
- Implemented OAuth methods: `validateAccessToken`, `fetchPublicationsWithOAuth`, `fetchSubscribersWithOAuth`, `getSubscriberCountWithOAuth`
- Used Bearer token authentication in all API requests: `Authorization: Bearer {accessToken}`
- Base URL: `https://api.kit.com/v1` as specified in PRD
- Handles API errors appropriately: 401/403 (invalid token), 429 (rate limit), 500+ (server errors)
- Returns 401 errors to trigger token refresh (errors are thrown with descriptive messages)
- API key methods return empty/false values since Kit only supports OAuth (required by interface for backward compatibility)
- Registered KitConnector in app.module.ts providers array
- Updated EspConnectionService.getConnector() to return KitConnector for EspType.KIT
- Files changed:
  - `apps/backend/src/connectors/kit.connector.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
  - `apps/backend/src/services/esp-connection.service.ts` (updated)
- **Learnings for future iterations:**
  - Connectors must implement all IEspConnector methods, even if not used (API key methods return empty/false for OAuth-only connectors)
  - OAuth connectors use `fetchPublicationsWithOAuth`, `fetchSubscribersWithOAuth`, `getSubscriberCountWithOAuth` method names (not overloads)
  - Handle flexible API response structures (data, publications, subscribers arrays may be nested differently)
  - Pagination handling should check both explicit pagination metadata and implicit pagination (page size vs results returned)
  - Status mapping functions help normalize ESP-specific status values to standard format
  - Always register new connectors in app.module.ts providers and inject into EspConnectionService
  - Update getConnector() switch statement to include new connector types
---

## Sun Jan 19 2026 - US-009
- Created OAuthTokenRefreshService with `refreshToken(espConnection: EspConnection)` method
- Method validates connection is OAuth-based and has refresh token
- Method calls ESP's token endpoint with grant_type=refresh_token, refresh_token, client_id, client_secret
- Method decrypts refresh token, exchanges it for new access token, encrypts new tokens, and updates database
- Updates `encryptedAccessToken`, `encryptedRefreshToken` (if new one provided), `tokenExpiresAt`, and `lastValidatedAt`
- Handles errors appropriately: BadRequestException for invalid/expired refresh tokens (400/401), InternalServerErrorException for other errors
- Returns TokenRefreshResult with accessToken, optional refreshToken, and expiresIn
- Registered service in app.module.ts providers array
- Files changed:
  - `apps/backend/src/services/oauth-token-refresh.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
  - `apps/backend/AGENTS.md` (updated)
- **Learnings for future iterations:**
  - Token refresh uses same pattern as token exchange: HttpService with firstValueFrom, URLSearchParams, application/x-www-form-urlencoded
  - OAuth token refresh may not always return a new refresh_token - keep existing one if not provided
  - Handle 400 (invalid refresh token) and 401 (expired/revoked refresh token) as BadRequestException with user-friendly messages
  - Always update lastValidatedAt when refreshing tokens to track when connection was last validated
  - Token refresh service should validate authMethod === 'oauth' and check for refresh token existence before attempting refresh
  - Service should validate ESP type supports OAuth (Kit, Mailchimp) before attempting refresh
---

## Sun Jan 19 2026 - US-010
- Created OAuthTokenRefreshSchedulerService that schedules proactive token refresh jobs
- Scheduler runs every 5 minutes using cron pattern "*/5 * * * *" (every 5 minutes)
- Created OAuthTokenRefreshProcessor that processes token refresh jobs via BullMQ queue
- Processor finds all OAuth connections where `tokenExpiresAt` is within 10 minutes using TypeORM `LessThanOrEqual()` query
- Processor calls `OAuthTokenRefreshService.refreshToken()` for each connection
- Processor handles errors gracefully - logs failures but continues processing other connections to prevent one failure from blocking all refreshes
- Registered `oauth-token-refresh` queue in BullModule with retry policy (3 attempts, exponential backoff)
- Registered processor and scheduler service in app.module.ts providers array
- Scheduler checks for existing repeatable jobs before scheduling to avoid duplicates
- Files changed:
  - `apps/backend/src/processors/oauth-token-refresh.processor.ts` (new)
  - `apps/backend/src/services/oauth-token-refresh-scheduler.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated)
  - `apps/backend/AGENTS.md` (updated)
- **Learnings for future iterations:**
  - Cron pattern "*/5 * * * *" means "every 5 minutes" (every 5 minutes at any hour, day, month)
  - Use TypeORM `LessThanOrEqual()` with calculated threshold date to find records expiring within a time window
  - When processing multiple items in a job, handle errors per item and continue processing others (don't fail entire job on single item failure)
  - Log success and error counts separately for better observability of job execution
  - Token refresh jobs should proactively refresh tokens before expiry (10-minute window) to prevent API calls from failing due to expired tokens
  - Always register new queues in `BullModule.registerQueue()` with appropriate retry policies
---

## Sun Jan 19 2026 - US-011
- Updated EspConnectionService to inject OAuthTokenRefreshService
- Created `callOAuthConnectorMethodWithRetry()` wrapper method that automatically handles 401 errors from OAuth connector methods
- Wrapper method catches 401 errors (detected by error message containing "401" or "Invalid access token"), refreshes the token using OAuthTokenRefreshService, reloads connection from database, and retries the original call once with the new token
- Updated `getSubscriberCount()` to support OAuth connections using the wrapper method
- Created `getSubscriberCountWithOAuth()` private method that uses the wrapper for OAuth connections
- Retry is limited to once per request using `retried` flag to prevent infinite loops
- If token refresh fails, throws InternalServerErrorException with user-friendly message
- Files changed:
  - `apps/backend/src/services/esp-connection.service.ts` (updated)
  - `apps/backend/AGENTS.md` (updated)
- **Learnings for future iterations:**
  - OAuth connector methods throw generic Error objects with messages like "Invalid access token: 401" when they receive 401 responses - check error message for "401" or "Invalid access token" patterns to detect 401 errors
  - After token refresh, always reload the connection from database using `espConnectionRepository.findOne()` to get the updated encrypted token before decrypting and using it
  - Use a `retried` boolean flag parameter in recursive retry methods to limit retries to once per request and prevent infinite loops
  - The wrapper method pattern (`callOAuthConnectorMethodWithRetry`) can be reused for other OAuth connector methods (fetchSubscribersWithOAuth, fetchPublicationsWithOAuth, etc.) in future stories
  - When updating OAuth connections after token refresh, the database save happens in OAuthTokenRefreshService, so reload the connection in the calling service to get the latest data
  - Error detection for 401 should check both error.message and error.response.status for robustness
---

## Sun Jan 19 2026 - US-012
- Added `createOAuthConnection()` method to EspConnectionService
- Method encrypts access token and refresh token using EncryptionService before storing
- Method validates access token using connector's `validateAccessToken()` method
- Method calls `fetchPublicationsWithOAuth()` to get all publications from the ESP
- Method stores all publication IDs in `publicationIds` JSONB array
- Method sets `authMethod: 'oauth'` and calculates `tokenExpiresAt` from `expiresIn` parameter
- Method sets `status: 'active'` if validation succeeds
- Existing `createConnection()` already sets `authMethod: 'api_key'` for API key connections (no changes needed)
- Files changed:
  - `apps/backend/src/services/esp-connection.service.ts` (updated)
- **Learnings for future iterations:**
  - `createOAuthConnection()` checks if connector supports OAuth by verifying `validateAccessToken` and `fetchPublicationsWithOAuth` methods exist before attempting to use them
  - OAuth connections store all publication IDs in `publicationIds` JSONB array (not just a single `publicationId` like API key connections)
  - Token expiry is calculated by adding `expiresIn` seconds to current time: `new Date()` then `setSeconds(getSeconds() + expiresIn)`
  - Always validate OAuth access token before creating connection to ensure it's valid and user has access
  - The method throws BadRequestException if OAuth is not supported for the ESP type or if access token validation fails
  - Empty publication arrays are stored as `null` in the database (check `publicationIds.length > 0` before storing)
---

## Sun Jan 19 2026 - US-013
- Updated OAuth callback endpoint to use `EspConnectionService.createOAuthConnection()` method instead of basic connection creation
- Replaced manual connection creation with service method that validates access token, fetches publications, and stores all publication IDs
- Added logic to handle existing OAuth connections: checks if user already has OAuth connection for this ESP type and deletes it before creating new one (ensures only one active OAuth connection per ESP type per user)
- After connection creation, triggers sync job by adding to `subscriberSyncQueue` with job name 'sync-publication'
- Marks connection as syncing before adding to queue using `updateSyncStatus()`
- Handles sync trigger errors gracefully - logs error but doesn't fail OAuth callback (connection is created successfully, user can manually trigger sync later)
- Handles connection creation errors appropriately - wraps BadRequestException from service as InternalServerErrorException with descriptive message
- Redirects to frontend success page with connection ID and oauth=success parameter
- Files changed:
  - `apps/backend/src/controllers/esp-connection.controller.ts` (updated)
- **Learnings for future iterations:**
  - When handling existing connections, delete old OAuth connections before creating new ones to avoid duplicates (users typically want to reconnect with fresh tokens)
  - Sync trigger should be wrapped in try-catch to prevent OAuth callback from failing if sync service doesn't support OAuth yet (US-014 will add OAuth sync support)
  - The sync processor calls `subscriberSyncService.syncSubscribers()` which currently only supports API key connections - OAuth sync support will be added in US-014
  - Always mark connection as syncing before adding job to queue to prevent race conditions
  - OAuth callback should handle errors gracefully - connection creation is the critical path, sync trigger is secondary
  - When deleting existing connections, use `repository.remove()` which handles cascading deletes if configured
---

## Sun Jan 19 2026 - US-014
- Updated SubscriberSyncService to support OAuth connections in addition to API key connections
- Injected KitConnector and OAuthTokenRefreshService into SubscriberSyncService constructor
- Updated `getConnector()` method to include Kit connector (EspType.KIT)
- Created `callOAuthConnectorMethodWithRetry()` wrapper method that automatically handles 401 errors from OAuth connector methods by refreshing tokens and retrying once
- Updated `syncSubscribers()` to check `authMethod` field and handle both API key and OAuth connections
- For API key connections, uses existing flow: decrypt API key, call `fetchSubscribers()`, process subscribers
- For OAuth connections: decrypts access token, iterates through `publicationIds` array, calls `fetchSubscribersWithOAuth()` for each publication with automatic token refresh on 401
- Handles errors gracefully: continues syncing other publications if one fails, continues processing other subscribers if one fails
- After token refresh, reloads connection from database to get updated encrypted token before continuing
- Files changed:
  - `apps/backend/src/services/subscriber-sync.service.ts` (updated)
- **Learnings for future iterations:**
  - The `callOAuthConnectorMethodWithRetry()` pattern from EspConnectionService can be reused in SubscriberSyncService for consistent token refresh handling
  - OAuth connections store multiple publication IDs in `publicationIds` JSONB array - need to iterate through all publications when syncing
  - After token refresh, always reload the connection from database to get the updated encrypted token before using it in subsequent calls
  - For OAuth connections, fallback to single `publicationId` field if `publicationIds` array is not available (backward compatibility)
  - When syncing multiple publications, handle errors per publication and continue syncing others - don't fail entire sync if one publication fails
  - Use Logger instead of console.error for better logging consistency in NestJS services
  - The sync service now supports both auth methods seamlessly - API key flow unchanged, OAuth flow added alongside it
---

## Sun Jan 19 2026 - US-015
- Added `initiateOAuth()` function to `espConnectionApi` namespace in frontend API client
- Function accepts `provider: 'kit' | 'mailchimp'` parameter and authentication token
- Function calls `GET /esp-connections/oauth/initiate/:provider` endpoint with Bearer token authentication
- Function handles redirect response (302/301) by reading `Location` header and navigating browser to OAuth provider
- Uses `redirect: 'manual'` in fetch options to prevent automatic redirect, then manually handles redirect by setting `window.location.href`
- Handles 401 errors appropriately with `onUnauthorized` callback and redirects to login
- Handles other errors with descriptive error messages
- All acceptance criteria met: proper TypeScript types, error handling, redirect handling, typecheck passes
- Files changed:
  - `apps/frontend/src/lib/api.ts` (updated)
- **Learnings for future iterations:**
  - OAuth initiation endpoints return redirect responses (302/301) that need to be handled manually
  - Use `redirect: 'manual'` in fetch options to prevent automatic redirect, then read `Location` header and navigate browser using `window.location.href`
  - OAuth flows require browser navigation (not just API calls) since user needs to authorize on OAuth provider's website
  - Always validate token is present before making OAuth initiation request (throw error if missing)
  - The function returns `Promise<void>` since it redirects the browser and doesn't return data
---

## Sun Jan 19 2026 - US-016
- Updated frontend to support OAuth flow for Kit
- Updated backend OAuth callback redirect URL from `/esp-connections/{id}` to `/dashboard/esp/{id}` to match frontend route structure
- Updated onboarding page (`src/app/onboarding/page.tsx`) to show "Connect with OAuth" button for Kit and Mailchimp (providers that support OAuth)
- Updated onboarding API key page (`src/app/onboarding/api-key/page.tsx`) to detect OAuth support and show OAuth button instead of API key form for Kit/Mailchimp
- Updated "New ESP Connection" page (`src/app/dashboard/esp/new/page.tsx`) to support OAuth for Kit and Mailchimp
- Updated ESP detail page (`src/app/dashboard/esp/[id]/page.tsx`) to show success message when `oauth=success` query parameter is present
- OAuth success message uses Alert component and automatically hides after 5 seconds
- All pages handle OAuth errors appropriately with error messages
- Files changed:
  - `apps/backend/src/controllers/esp-connection.controller.ts` (updated redirect URL)
  - `apps/frontend/src/app/onboarding/page.tsx` (added OAuth button for Kit/Mailchimp)
  - `apps/frontend/src/app/onboarding/api-key/page.tsx` (detect OAuth support, show OAuth button)
  - `apps/frontend/src/app/dashboard/esp/new/page.tsx` (added OAuth support for Kit/Mailchimp)
  - `apps/frontend/src/app/dashboard/esp/[id]/page.tsx` (added OAuth success message display)
- **Learnings for future iterations:**
  - OAuth callback redirect URLs must match frontend route structure (backend redirects to `/dashboard/esp/{id}`, not `/esp-connections/{id}`)
  - Use `supportsOAuth` boolean check to conditionally show OAuth buttons vs API key forms
  - OAuth success messages can be shown using Alert component with query parameter detection
  - Remove query parameters from URL after displaying success message to keep URLs clean
  - OAuth initiation automatically redirects browser, so no need for manual navigation after calling `initiateOAuth()`
  - Always run `yarn format` before committing to fix prettier formatting issues
---

## Sun Jan 19 2026 - US-017
- Updated onboarding flow to support OAuth connections and redirect to Stripe step after OAuth success
- Added `isOnboarding` boolean field to OAuthState entity to track if OAuth flow is part of onboarding
- Created migration `1768744200000-AddIsOnboardingToOAuthState.ts` to add `isOnboarding` column to `oauth_states` table
- Updated OAuthStateService to accept and store `isOnboarding` flag in `createState()` method
- Updated OAuthStateService `validateState()` to return `isOnboarding` flag
- Updated OAuth initiate endpoint to accept optional `onboarding` query parameter
- Updated OAuth callback endpoint to check `isOnboarding` flag and redirect to `/onboarding/stripe` if true, otherwise redirect to ESP detail page
- Updated frontend API client `initiateOAuth()` to accept optional `onboarding` parameter and pass it as query parameter
- Updated onboarding pages (`/onboarding/page.tsx` and `/onboarding/api-key/page.tsx`) to pass `onboarding=true` when initiating OAuth
- Migration executed successfully, all typechecks pass, lint passes
- Files changed:
  - `apps/backend/src/entities/oauth-state.entity.ts` (added isOnboarding field)
  - `apps/backend/src/migrations/1768744200000-AddIsOnboardingToOAuthState.ts` (new)
  - `apps/backend/src/services/oauth-state.service.ts` (updated to handle isOnboarding)
  - `apps/backend/src/controllers/esp-connection.controller.ts` (updated to accept onboarding param and redirect accordingly)
  - `apps/frontend/src/lib/api.ts` (updated initiateOAuth to accept onboarding parameter)
  - `apps/frontend/src/app/onboarding/page.tsx` (pass onboarding=true)
  - `apps/frontend/src/app/onboarding/api-key/page.tsx` (pass onboarding=true)
  - `apps/frontend/next-env.d.ts` (fixed prettier linting issue)
- **Learnings for future iterations:**
  - Use boolean flags in OAuth state to track flow context (e.g., onboarding vs regular connection)
  - OAuth callback redirects can be conditional based on flow context stored in OAuth state
  - When adding new fields to entities, always create migrations with `IF NOT EXISTS` for idempotency
  - Frontend API client functions can accept optional parameters to customize backend behavior
  - OAuth flows initiated from onboarding should redirect to onboarding steps, not dashboard pages
  - The `isOnboarding` flag is stored in the database and retrieved during state validation, allowing the callback to make routing decisions
---
