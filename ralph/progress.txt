# Ralph Progress Log
Started: Sat Jan 17 2026
---

## Codebase Patterns
- TypeORM entities are placed in `src/entities/` directory with `.entity.ts` extension
- Migrations are placed in `src/migrations/` and use timestamp-based naming (e.g., `1737129600000-MigrationName.ts`)
- PostgreSQL enum types must be created explicitly in migrations using `CREATE TYPE` with `DO $$ BEGIN ... EXCEPTION ... END $$;` pattern to handle existing types
- Entities use TypeORM decorators: `@Entity()`, `@PrimaryGeneratedColumn('uuid')`, `@Column()`, `@CreateDateColumn()`, `@UpdateDateColumn()`
- Foreign keys use `@ManyToOne()` and `@JoinColumn()` decorators
- Unique constraints use `@Index()` decorator with `isUnique: true`
- The data-source.ts file uses `entities: ['src/**/*.entity.ts']` pattern to auto-discover entities
- Migrations reference built files in `dist/migrations/*.js` but source files are in `src/migrations/`

## 2026-01-17 - US-001
- Created `EspConnection` entity with all required fields: id (UUID), userId, espType (enum), encryptedApiKey, publicationId, status (enum), lastValidatedAt, createdAt, updatedAt
- Created `Subscriber` entity with all required fields: id (UUID), espConnectionId (FK), externalId, encryptedEmail, maskedEmail, status (enum), firstName, lastName, subscribedAt, unsubscribedAt, metadata (JSONB), createdAt, updatedAt
- Created migration file `1737129600000-CreateEspConnectionAndSubscriber.ts` with proper PostgreSQL enum type creation
- Added unique index on `espConnectionId + externalId` for subscribers table
- Added foreign key relationship from subscribers to esp_connections with CASCADE delete
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` (new)
  - `apps/backend/src/entities/subscriber.entity.ts` (new)
  - `apps/backend/src/migrations/1737129600000-CreateEspConnectionAndSubscriber.ts` (new)
- **Learnings for future iterations:**
  - PostgreSQL requires explicit enum type creation in migrations before using them in table columns
  - Use `DO $$ BEGIN ... EXCEPTION WHEN duplicate_object THEN null; END $$;` pattern to safely create enum types that may already exist
  - TypeORM's `@Index()` decorator with `isUnique: true` creates a unique constraint, which is needed for the upsert pattern in US-013
  - The `@OneToMany()` relationship on EspConnection and `@ManyToOne()` on Subscriber creates the proper bidirectional relationship
  - Migration files should include both `up()` and `down()` methods for rollback capability

## 2026-01-18 - US-002
- Created `EncryptionService` with `encrypt()` and `decrypt()` methods using AES-256-GCM encryption
- Service uses `ENCRYPTION_KEY` environment variable and derives a 256-bit key using PBKDF2
- Implemented error handling for encryption/decryption failures with descriptive error messages
- Uses AES-256-GCM algorithm for authenticated encryption (provides both confidentiality and authenticity)
- Encryption format: `iv:tag:encryptedData` (all base64 encoded) to support unique IV per encryption
- Added `EncryptionService` to `AppModule` providers
- Files changed:
  - `apps/backend/src/services/encryption.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include EncryptionService)
- **Learnings for future iterations:**
  - Services are placed in `src/services/` directory with `.service.ts` extension
  - Use Node.js built-in `crypto` module for encryption (no external dependencies needed)
  - AES-256-GCM provides authenticated encryption, which is more secure than CBC mode
  - PBKDF2 key derivation ensures consistent 256-bit key regardless of input key length
  - Each encryption uses a unique IV (initialization vector) for security
  - The service throws descriptive errors if `ENCRYPTION_KEY` is missing or if encryption/decryption fails
  - ConfigService is already available globally via `ConfigModule.forRoot({ isGlobal: true })` in AppModule

## 2026-01-18 - US-003
- Created `maskEmail()` utility function in `src/utils/email.util.ts` that masks the local part of email addresses while keeping the domain visible
- Function handles edge cases: single character emails (e.g., "a@example.com" → "a****@example.com"), very short emails, and invalid formats (throws descriptive errors)
- Uses regex validation to ensure email format is valid before processing
- Masking pattern: shows first character of local part followed by 4 asterisks (e.g., "john.doe@example.com" → "j****@example.com")
- Files changed:
  - `apps/backend/src/utils/email.util.ts` (new)
- **Learnings for future iterations:**
  - Utility functions (non-injectable, pure functions) are placed in `src/utils/` directory with `.util.ts` extension
  - Email validation uses regex pattern `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` to ensure basic email format
  - The function throws descriptive errors for invalid inputs (empty strings, non-string types, invalid format)
  - Masking always shows the first character of the local part for consistency, even for single-character emails

## 2026-01-18 - US-004
- Created `IEspConnector` interface in `src/interfaces/esp-connector.interface.ts` with three methods: `validateApiKey()`, `fetchPublications()`, and `fetchSubscribers()`
- Created `Publication` and `SubscriberData` interfaces in `src/interfaces/esp.interface.ts` to define the data structures returned by ESP APIs
- `Publication` interface includes `id`, `name`, and allows additional ESP-specific fields via index signature
- `SubscriberData` interface includes `id` (ESP's subscriber ID), `email`, `status`, `firstName`, `lastName`, `subscribedAt`, `unsubscribedAt`, and allows additional ESP-specific fields via index signature
- All interfaces use proper TypeScript typing with optional/nullable fields where appropriate
- Files changed:
  - `apps/backend/src/interfaces/esp.interface.ts` (new)
  - `apps/backend/src/interfaces/esp-connector.interface.ts` (new)
- **Learnings for future iterations:**
  - Interfaces are placed in `src/interfaces/` directory with `.interface.ts` extension
  - Use index signatures (`[key: string]: any`) to allow ESP-specific fields while maintaining type safety for known fields
  - The `IEspConnector` interface defines the contract that all ESP implementations must follow, enabling a consistent pattern for multiple ESP integrations
  - `Publication` and `SubscriberData` interfaces represent the raw data from ESP APIs before mapping to our database schema
  - The `publicationId` parameter in `validateApiKey()` is optional to support ESPs that may or may not require it for validation

## 2026-01-18 - US-005
- Created `BeehiivConnector` class in `src/connectors/beehiiv.connector.ts` implementing `IEspConnector` interface
- Implemented `validateApiKey()` method that calls `GET https://api.beehiiv.com/v2/publications` with Bearer token authentication
- `validateApiKey()` returns true if status 200 and optionally validates that a specific publication exists
- Implemented `fetchPublications()` method that fetches all publications from Beehiiv API and maps them to `Publication[]` format
- Implemented `fetchSubscribers()` method with pagination support that fetches all subscribers from a publication using `GET https://api.beehiiv.com/v2/publications/:publicationId/subscriptions`
- Added comprehensive error handling for API errors: 401/403 (invalid API key), 404 (publication not found), 429 (rate limit), 500+ (server errors)
- Created `mapBeehiivStatus()` helper method to normalize Beehiiv status values to our standard format
- Installed `axios` and `@nestjs/axios` packages for HTTP requests
- Added `HttpModule` to `AppModule` imports and `BeehiivConnector` to providers
- Files changed:
  - `apps/backend/src/connectors/beehiiv.connector.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include HttpModule and BeehiivConnector)
  - `apps/backend/package.json` (updated with axios and @nestjs/axios dependencies)
- **Learnings for future iterations:**
  - ESP connectors are placed in `src/connectors/` directory with `.connector.ts` extension
  - Use `@nestjs/axios` HttpModule and HttpService for making HTTP requests in NestJS
  - Use `firstValueFrom()` from RxJS to convert observables to promises when using HttpService
  - Beehiiv API uses Bearer token authentication in the Authorization header
  - Beehiiv API pagination: check `total_pages` or `pages` in response to determine if more pages exist
  - Handle pagination by looping through pages until `hasMore` is false
  - Map ESP-specific status values to our standard enum values (e.g., 'subscribed' → 'active', 'spam' → 'bounced')
  - Always include all ESP-specific fields in the response using spread operator (`...sub`) to preserve metadata
  - Error handling should distinguish between authentication errors (401/403), not found (404), rate limits (429), and server errors (500+)
  - The connector should throw descriptive errors that can be caught and handled by calling services

## 2026-01-18 - US-013
- Created `SubscriberService` with `findByEspConnection()` and `upsertSubscriber()` methods
- Created `CreateSubscriberDto` in `src/dto/create-subscriber.dto.ts` to define the data structure for creating/updating subscribers
- `findByEspConnection()` retrieves all subscribers for a given ESP connection, ordered by creation date (newest first)
- `upsertSubscriber()` implements upsert pattern: finds existing subscriber by unique key (`externalId` + `espConnectionId`), updates if found, creates new if not
- Uses TypeORM repository pattern with `@InjectRepository(Subscriber)` decorator
- Registered `Subscriber` entity with `TypeOrmModule.forFeature([Subscriber])` in `AppModule`
- Added `SubscriberService` to `AppModule` providers
- Files changed:
  - `apps/backend/src/dto/create-subscriber.dto.ts` (new)
  - `apps/backend/src/services/subscriber.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include TypeOrmModule.forFeature and SubscriberService)
  - `apps/backend/AGENTS.md` (updated with service patterns and directory structure)
- **Learnings for future iterations:**
  - DTOs are placed in `src/dto/` directory with `.dto.ts` extension
  - Services that use TypeORM repositories must inject them using `@InjectRepository(Entity)` decorator
  - Register entities with `TypeOrmModule.forFeature([Entity])` in the module imports to make repositories available for injection
  - The upsert pattern uses `findOne()` to check existence, then `save()` to create or update
  - The unique constraint on `externalId + espConnectionId` (from US-001) ensures data integrity for the upsert operation
  - Use `Object.assign()` to update existing entity properties before saving
  - Use `repository.create()` to create new entity instances before saving
  - Services are injectable classes decorated with `@Injectable()` and added to module providers

## 2026-01-18 - US-006
- Created `EspConnectionService` with `createConnection()` method that validates API keys, encrypts them, and stores ESP connections
- Method validates `espType` against `EspType` enum and throws `BadRequestException` if invalid
- Uses `getConnector()` private method to get the appropriate ESP connector based on `espType` (currently supports BeehiivConnector)
- Validates API key using the connector's `validateApiKey()` method before saving
- Encrypts API key using `EncryptionService` before storing in database
- Sets `status` to `ACTIVE` if validation succeeds, throws `BadRequestException` if validation fails
- Sets `lastValidatedAt` timestamp to current date on successful validation
- Registered `EspConnection` entity with `TypeOrmModule.forFeature([EspConnection])` in `AppModule`
- Added `EspConnectionService` to `AppModule` providers
- Files changed:
  - `apps/backend/src/services/esp-connection.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include EspConnection entity and service)
- **Learnings for future iterations:**
  - Use a switch statement in `getConnector()` method to map `espType` enum values to connector instances
  - Inject connector instances (like `BeehiivConnector`) directly into the service constructor - they're already registered as providers
  - Validate input parameters (like `espType`) early in the method to provide clear error messages
  - Use `BadRequestException` from `@nestjs/common` for validation errors (400 status)
  - The service pattern: validate → encrypt → create entity → save to database
  - Always set `lastValidatedAt` timestamp when validation succeeds for audit purposes
  - The connector's `validateApiKey()` method handles API errors internally and returns boolean, so the service just needs to check the result

## 2026-01-18 - US-007
- Created `EspConnectionController` with `POST /api/esp-connections` endpoint
- Created `CreateEspConnectionDto` with validation decorators (`@IsNotEmpty()`, `@IsEnum()`, `@IsString()`) for request body validation
- Endpoint accepts `{ espType: EspType, apiKey: string, publicationId: string }` and validates all required fields
- Uses `EspConnectionService.createConnection()` to validate API key, encrypt it, and store the connection
- Returns connection record without `encryptedApiKey` field using object destructuring
- Handles errors appropriately: `BadRequestException` (400) from service validation, `InternalServerErrorException` (500) for other errors
- Configured global `ValidationPipe` in `main.ts` with `transform: true`, `whitelist: true`, and `forbidNonWhitelisted: true` options
- Installed `class-validator` and `class-transformer` packages for DTO validation
- Registered `EspConnectionController` in `AppModule` controllers array
- Files changed:
  - `apps/backend/src/dto/create-esp-connection.dto.ts` (new)
  - `apps/backend/src/controllers/esp-connection.controller.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include EspConnectionController)
  - `apps/backend/src/main.ts` (updated to configure global ValidationPipe)
  - `apps/backend/package.json` (updated with class-validator and class-transformer dependencies)
- **Learnings for future iterations:**
  - Controllers are placed in `src/controllers/` directory with `.controller.ts` extension
  - Use `class-validator` decorators (`@IsNotEmpty()`, `@IsString()`, `@IsEnum()`, etc.) on DTO properties for validation
  - Configure `ValidationPipe` globally in `main.ts` using `app.useGlobalPipes()` to enable automatic validation
  - Global ValidationPipe options: `transform: true` (auto-transform payloads to DTO instances), `whitelist: true` (strip non-whitelisted properties), `forbidNonWhitelisted: true` (throw error on non-whitelisted properties)
  - Use `@HttpCode(HttpStatus.CREATED)` decorator to set the HTTP status code for POST endpoints that create resources
  - Return type should use `Omit<Entity, 'sensitiveField'>` to exclude sensitive fields from the response
  - Use object destructuring to exclude sensitive fields: `const { encryptedApiKey, ...response } = entity`
  - Handle service exceptions appropriately: re-throw `BadRequestException` (400), wrap other errors in `InternalServerErrorException` (500)
  - Note: Authentication is not yet implemented, so `userId` is currently a placeholder. Future iterations should add authentication guards and extract userId from the authenticated user context
  - The controller delegates business logic to the service layer, keeping controllers thin and focused on HTTP concerns
---
