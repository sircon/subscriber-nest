# Ralph Progress Log
Started: Sat Jan 17 2026
---

## Codebase Patterns
- TypeORM entities are placed in `src/entities/` directory with `.entity.ts` extension
- Migrations are placed in `src/migrations/` and use timestamp-based naming (e.g., `1737129600000-MigrationName.ts`)
- PostgreSQL enum types must be created explicitly in migrations using `CREATE TYPE` with `DO $$ BEGIN ... EXCEPTION ... END $$;` pattern to handle existing types
- Entities use TypeORM decorators: `@Entity()`, `@PrimaryGeneratedColumn('uuid')`, `@Column()`, `@CreateDateColumn()`, `@UpdateDateColumn()`
- Foreign keys use `@ManyToOne()` and `@JoinColumn()` decorators
- Unique constraints use `@Index()` decorator with `isUnique: true`
- The data-source.ts file uses `entities: ['src/**/*.entity.ts']` pattern to auto-discover entities
- Migrations reference built files in `dist/migrations/*.js` but source files are in `src/migrations/`

## 2026-01-17 - US-001
- Created `EspConnection` entity with all required fields: id (UUID), userId, espType (enum), encryptedApiKey, publicationId, status (enum), lastValidatedAt, createdAt, updatedAt
- Created `Subscriber` entity with all required fields: id (UUID), espConnectionId (FK), externalId, encryptedEmail, maskedEmail, status (enum), firstName, lastName, subscribedAt, unsubscribedAt, metadata (JSONB), createdAt, updatedAt
- Created migration file `1737129600000-CreateEspConnectionAndSubscriber.ts` with proper PostgreSQL enum type creation
- Added unique index on `espConnectionId + externalId` for subscribers table
- Added foreign key relationship from subscribers to esp_connections with CASCADE delete
- Files changed:
  - `apps/backend/src/entities/esp-connection.entity.ts` (new)
  - `apps/backend/src/entities/subscriber.entity.ts` (new)
  - `apps/backend/src/migrations/1737129600000-CreateEspConnectionAndSubscriber.ts` (new)
- **Learnings for future iterations:**
  - PostgreSQL requires explicit enum type creation in migrations before using them in table columns
  - Use `DO $$ BEGIN ... EXCEPTION WHEN duplicate_object THEN null; END $$;` pattern to safely create enum types that may already exist
  - TypeORM's `@Index()` decorator with `isUnique: true` creates a unique constraint, which is needed for the upsert pattern in US-013
  - The `@OneToMany()` relationship on EspConnection and `@ManyToOne()` on Subscriber creates the proper bidirectional relationship
  - Migration files should include both `up()` and `down()` methods for rollback capability

## 2026-01-18 - US-002
- Created `EncryptionService` with `encrypt()` and `decrypt()` methods using AES-256-GCM encryption
- Service uses `ENCRYPTION_KEY` environment variable and derives a 256-bit key using PBKDF2
- Implemented error handling for encryption/decryption failures with descriptive error messages
- Uses AES-256-GCM algorithm for authenticated encryption (provides both confidentiality and authenticity)
- Encryption format: `iv:tag:encryptedData` (all base64 encoded) to support unique IV per encryption
- Added `EncryptionService` to `AppModule` providers
- Files changed:
  - `apps/backend/src/services/encryption.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include EncryptionService)
- **Learnings for future iterations:**
  - Services are placed in `src/services/` directory with `.service.ts` extension
  - Use Node.js built-in `crypto` module for encryption (no external dependencies needed)
  - AES-256-GCM provides authenticated encryption, which is more secure than CBC mode
  - PBKDF2 key derivation ensures consistent 256-bit key regardless of input key length
  - Each encryption uses a unique IV (initialization vector) for security
  - The service throws descriptive errors if `ENCRYPTION_KEY` is missing or if encryption/decryption fails
  - ConfigService is already available globally via `ConfigModule.forRoot({ isGlobal: true })` in AppModule

## 2026-01-18 - US-003
- Created `maskEmail()` utility function in `src/utils/email.util.ts` that masks the local part of email addresses while keeping the domain visible
- Function handles edge cases: single character emails (e.g., "a@example.com" → "a****@example.com"), very short emails, and invalid formats (throws descriptive errors)
- Uses regex validation to ensure email format is valid before processing
- Masking pattern: shows first character of local part followed by 4 asterisks (e.g., "john.doe@example.com" → "j****@example.com")
- Files changed:
  - `apps/backend/src/utils/email.util.ts` (new)
- **Learnings for future iterations:**
  - Utility functions (non-injectable, pure functions) are placed in `src/utils/` directory with `.util.ts` extension
  - Email validation uses regex pattern `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` to ensure basic email format
  - The function throws descriptive errors for invalid inputs (empty strings, non-string types, invalid format)
  - Masking always shows the first character of the local part for consistency, even for single-character emails

## 2026-01-18 - US-004
- Created `IEspConnector` interface in `src/interfaces/esp-connector.interface.ts` with three methods: `validateApiKey()`, `fetchPublications()`, and `fetchSubscribers()`
- Created `Publication` and `SubscriberData` interfaces in `src/interfaces/esp.interface.ts` to define the data structures returned by ESP APIs
- `Publication` interface includes `id`, `name`, and allows additional ESP-specific fields via index signature
- `SubscriberData` interface includes `id` (ESP's subscriber ID), `email`, `status`, `firstName`, `lastName`, `subscribedAt`, `unsubscribedAt`, and allows additional ESP-specific fields via index signature
- All interfaces use proper TypeScript typing with optional/nullable fields where appropriate
- Files changed:
  - `apps/backend/src/interfaces/esp.interface.ts` (new)
  - `apps/backend/src/interfaces/esp-connector.interface.ts` (new)
- **Learnings for future iterations:**
  - Interfaces are placed in `src/interfaces/` directory with `.interface.ts` extension
  - Use index signatures (`[key: string]: any`) to allow ESP-specific fields while maintaining type safety for known fields
  - The `IEspConnector` interface defines the contract that all ESP implementations must follow, enabling a consistent pattern for multiple ESP integrations
  - `Publication` and `SubscriberData` interfaces represent the raw data from ESP APIs before mapping to our database schema
  - The `publicationId` parameter in `validateApiKey()` is optional to support ESPs that may or may not require it for validation

## 2026-01-18 - US-005
- Created `BeehiivConnector` class in `src/connectors/beehiiv.connector.ts` implementing `IEspConnector` interface
- Implemented `validateApiKey()` method that calls `GET https://api.beehiiv.com/v2/publications` with Bearer token authentication
- `validateApiKey()` returns true if status 200 and optionally validates that a specific publication exists
- Implemented `fetchPublications()` method that fetches all publications from Beehiiv API and maps them to `Publication[]` format
- Implemented `fetchSubscribers()` method with pagination support that fetches all subscribers from a publication using `GET https://api.beehiiv.com/v2/publications/:publicationId/subscriptions`
- Added comprehensive error handling for API errors: 401/403 (invalid API key), 404 (publication not found), 429 (rate limit), 500+ (server errors)
- Created `mapBeehiivStatus()` helper method to normalize Beehiiv status values to our standard format
- Installed `axios` and `@nestjs/axios` packages for HTTP requests
- Added `HttpModule` to `AppModule` imports and `BeehiivConnector` to providers
- Files changed:
  - `apps/backend/src/connectors/beehiiv.connector.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include HttpModule and BeehiivConnector)
  - `apps/backend/package.json` (updated with axios and @nestjs/axios dependencies)
- **Learnings for future iterations:**
  - ESP connectors are placed in `src/connectors/` directory with `.connector.ts` extension
  - Use `@nestjs/axios` HttpModule and HttpService for making HTTP requests in NestJS
  - Use `firstValueFrom()` from RxJS to convert observables to promises when using HttpService
  - Beehiiv API uses Bearer token authentication in the Authorization header
  - Beehiiv API pagination: check `total_pages` or `pages` in response to determine if more pages exist
  - Handle pagination by looping through pages until `hasMore` is false
  - Map ESP-specific status values to our standard enum values (e.g., 'subscribed' → 'active', 'spam' → 'bounced')
  - Always include all ESP-specific fields in the response using spread operator (`...sub`) to preserve metadata
  - Error handling should distinguish between authentication errors (401/403), not found (404), rate limits (429), and server errors (500+)
  - The connector should throw descriptive errors that can be caught and handled by calling services

## 2026-01-18 - US-013
- Created `SubscriberService` with `findByEspConnection()` and `upsertSubscriber()` methods
- Created `CreateSubscriberDto` in `src/dto/create-subscriber.dto.ts` to define the data structure for creating/updating subscribers
- `findByEspConnection()` retrieves all subscribers for a given ESP connection, ordered by creation date (newest first)
- `upsertSubscriber()` implements upsert pattern: finds existing subscriber by unique key (`externalId` + `espConnectionId`), updates if found, creates new if not
- Uses TypeORM repository pattern with `@InjectRepository(Subscriber)` decorator
- Registered `Subscriber` entity with `TypeOrmModule.forFeature([Subscriber])` in `AppModule`
- Added `SubscriberService` to `AppModule` providers
- Files changed:
  - `apps/backend/src/dto/create-subscriber.dto.ts` (new)
  - `apps/backend/src/services/subscriber.service.ts` (new)
  - `apps/backend/src/app.module.ts` (updated to include TypeOrmModule.forFeature and SubscriberService)
  - `apps/backend/AGENTS.md` (updated with service patterns and directory structure)
- **Learnings for future iterations:**
  - DTOs are placed in `src/dto/` directory with `.dto.ts` extension
  - Services that use TypeORM repositories must inject them using `@InjectRepository(Entity)` decorator
  - Register entities with `TypeOrmModule.forFeature([Entity])` in the module imports to make repositories available for injection
  - The upsert pattern uses `findOne()` to check existence, then `save()` to create or update
  - The unique constraint on `externalId + espConnectionId` (from US-001) ensures data integrity for the upsert operation
  - Use `Object.assign()` to update existing entity properties before saving
  - Use `repository.create()` to create new entity instances before saving
  - Services are injectable classes decorated with `@Injectable()` and added to module providers
---
