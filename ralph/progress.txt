# Ralph Progress Log
Started: Sun Jan 18 09:32:48 CET 2026

## Codebase Patterns
- TypeORM entities use `@Entity`, `@Column`, and relationship decorators (`@ManyToOne`, `@OneToMany`)
- Enums are defined at the top of entity files and exported for reuse
- Entity IDs use UUID type with `@PrimaryGeneratedColumn('uuid')`
- Migrations use DO $$ BEGIN ... EXCEPTION WHEN duplicate_object pattern for idempotent enum creation
- Foreign key relationships use `@JoinColumn({ name: 'columnName' })` with explicit column naming
- Migration files are timestamped and must be in `src/migrations/` (compiled to `dist/migrations/`)
- Use `columnExists` check pattern to make migrations idempotent: `table?.columns.find((col) => col.name === 'columnName')`
- Always run `turbo run build --filter=backend` before running migrations
- Migration command: `cd apps/backend && yarn db:migrate`

---

## 2026-01-18 09:33 - US-001
- Created SyncHistory entity with all required fields (id, espConnectionId, status, startedAt, completedAt, errorMessage, createdAt)
- Added SyncHistoryStatus enum with 'success' and 'failed' values
- Added @ManyToOne relationship from SyncHistory to EspConnection
- Updated EspConnection entity to include @OneToMany relationship to SyncHistory
- Created migration 1737220000000-CreateSyncHistory.ts to create sync_history table with foreign key constraint
- Made existing AddSyncStatusToEspConnection migration idempotent by adding column existence check
- Files changed:
  - `apps/backend/src/entities/sync-history.entity.ts` - New entity file
  - `apps/backend/src/entities/esp-connection.entity.ts` - Added import and syncHistory relationship
  - `apps/backend/src/migrations/1737220000000-CreateSyncHistory.ts` - New migration file
  - `apps/backend/src/migrations/1737200000000-AddSyncStatusToEspConnection.ts` - Added idempotency check
- **Learnings for future iterations:**
  - The data-source.ts uses `src/**/*.entity.ts` pattern to auto-discover entities
  - When adding relationships, both entities need to be updated (ManyToOne side and OneToMany side)
  - Foreign key CASCADE delete ensures sync history is removed when connection is deleted
  - Existing migrations may need idempotency fixes if database already has changes applied
  - Migration timestamps should be sequential and higher than existing migrations
---

## 2026-01-18 10:15 - US-002
- Updated SubscriberSyncProcessor to create SyncHistory records for tracking sync operations
- Added SyncHistory repository injection to the processor
- Created sync history record at job start with status: 'success' and startedAt timestamp
- Updated sync history with completedAt timestamp when sync completes successfully
- Updated sync history with status: 'failed', completedAt, and errorMessage when sync fails after all retries
- Used BullMQ's job.attemptsMade and job.opts.attempts to detect final retry attempt
- Files changed:
  - `apps/backend/src/processors/subscriber-sync.processor.ts` - Added sync history tracking
- **Learnings for future iterations:**
  - BullMQ jobs have `attemptsMade` and `opts.attempts` properties to track retry attempts
  - When a job will be retried, we should only record final failure after all retries exhausted
  - Repository injection in processors follows same pattern as in services/controllers
  - Optimistic approach: Create sync history with 'success' status, update to 'failed' only if needed
  - Always wrap database updates in try-catch to prevent processor failures from cascading
---

## 2026-01-18 15:30 - US-003
- Created SyncHistoryService with findByEspConnection method
- Method queries sync history records for a specific ESP connection
- Returns records ordered by startedAt DESC (most recent first)
- Optional limit parameter defaults to 50 if not provided
- Includes ESP connection relationship in query using relations: ['espConnection']
- Registered SyncHistory entity in TypeOrmModule.forFeature()
- Registered SyncHistoryService in AppModule providers
- Files changed:
  - `apps/backend/src/services/sync-history.service.ts` - New service file
  - `apps/backend/src/app.module.ts` - Added SyncHistory entity and SyncHistoryService registration
- **Learnings for future iterations:**
  - Services follow standard NestJS pattern: @Injectable() decorator, constructor injection
  - Repository injection uses @InjectRepository(Entity) pattern
  - TypeORM find() options: where (filters), relations (eager load), order (sorting), take (limit)
  - Default parameter values in TypeScript: `limit: number = 50` syntax
  - Services must be registered in AppModule providers array to be injectable
  - Entities must be in TypeOrmModule.forFeature() array to inject their repositories
---

## 2026-01-18 18:00 - US-004
- Added GET /esp-connections/:id/sync-history endpoint to EspConnectionController
- Endpoint accepts optional query parameter 'limit' (default: 50)
- Validates ESP connection exists and belongs to requesting user via espConnectionService.findById()
- Returns array of sync history records without espConnection relation to avoid exposing sensitive data
- Follows existing error handling pattern: NotFoundException (404), BadRequestException → ForbiddenException (403)
- Uses Omit<SyncHistory, 'espConnection'>[] return type to properly type the response
- Files changed:
  - `apps/backend/src/controllers/esp-connection.controller.ts` - Added sync history endpoint
- **Learnings for future iterations:**
  - Controllers must import Query decorator for query parameters
  - Query parameters in NestJS can be optional by using `@Query('param') param?: type`
  - Required parameters decorated with @CurrentUser or @Param must come before optional @Query parameters
  - When removing fields from returned objects, use Omit<Type, 'field'>[] for proper typing
  - Controller error handling pattern: validate ownership first, then return appropriate 403/404 errors
  - SyncHistoryService was already registered in AppModule, so no module changes needed
---

## 2026-01-18 21:30 - US-005
- Added GET /esp-connections/:id/subscribers endpoint to EspConnectionController
- Created findByEspConnectionPaginated method in SubscriberService
- Endpoint accepts query parameters: page (default: 1), limit (default: 50), status (optional filter)
- Returns paginated response with data, total, page, limit, and totalPages
- Subscribers returned with maskedEmail (encryptedEmail excluded for security)
- Validates ESP connection exists and belongs to requesting user
- Follows existing error handling pattern: NotFoundException (404), BadRequestException → ForbiddenException (403)
- Files changed:
  - `apps/backend/src/services/subscriber.service.ts` - Added paginated query method
  - `apps/backend/src/controllers/esp-connection.controller.ts` - Added subscribers endpoint and injected SubscriberService
- **Learnings for future iterations:**
  - Paginated responses follow pattern: `{ data: T[], total, page, limit, totalPages }`
  - Use TypeORM skip/take for pagination: `skip: (page - 1) * limit, take: limit`
  - Calculate totalPages: `Math.ceil(total / limit)`
  - When filtering is optional, build where clause conditionally: `if (status) where.status = status`
  - Remove sensitive fields from responses by destructuring: `const { encryptedEmail, ...data } = subscriber`
  - Service injection in controllers: add to constructor parameters and import service class
  - SubscriberService was already registered in AppModule, so no module changes needed
---

## 2026-01-18 23:45 - US-006
- Created new SubscriberController with POST /subscribers/:id/unmask endpoint
- Endpoint validates subscriber exists and belongs to a connection owned by requesting user
- Fetches subscriber with espConnection relation to validate ownership via userId comparison
- Uses EncryptionService.decrypt() to decrypt the encryptedEmail field
- Returns { email: string } with decrypted email
- Follows existing error handling pattern: NotFoundException (404), ForbiddenException (403)
- Registered SubscriberController in AppModule controllers array
- Files changed:
  - `apps/backend/src/controllers/subscriber.controller.ts` - New controller file
  - `apps/backend/src/app.module.ts` - Added SubscriberController registration
- **Learnings for future iterations:**
  - When validating ownership through a relationship, use relations: ['espConnection'] in query
  - Compare espConnection.userId with current user.id for ownership validation
  - EncryptionService.decrypt() throws errors that should be caught and returned as 500
  - New controllers must be both imported and added to controllers array in AppModule
  - Subscriber entity already registered in TypeOrmModule.forFeature(), so repository injection works
  - Pattern for sensitive operations: fetch with relations, validate ownership, perform operation, handle errors
---
